{"ast":null,"code":"/*******************************************************************************\r\n * Copyright (c) 2013 IBM Corp.\r\n *\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * and Eclipse Distribution License v1.0 which accompany this distribution.\r\n *\r\n * The Eclipse Public License is available at\r\n *    http://www.eclipse.org/legal/epl-v10.html\r\n * and the Eclipse Distribution License is available at\r\n *   http://www.eclipse.org/org/documents/edl-v10.php.\r\n *\r\n * Contributors:\r\n *    Andrew Banks - initial API and implementation and initial documentation\r\n *******************************************************************************/\n// Only expose a single object name in the global namespace.\n// Everything must go through this module. Global Paho.MQTT module\n// only has a single public function, client, which returns\n// a Paho.MQTT client object given connection details.\n\n/**\r\n * Send and receive messages using web browsers.\r\n * <p>\r\n * This programming interface lets a JavaScript client application use the MQTT V3.1 or\r\n * V3.1.1 protocol to connect to an MQTT-supporting messaging server.\r\n *\r\n * The function supported includes:\r\n * <ol>\r\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number.\r\n * <li>Specifying options that relate to the communications link with the server,\r\n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\r\n * <li>Subscribing to and receiving messages from MQTT Topics.\r\n * <li>Publishing messages to MQTT Topics.\r\n * </ol>\r\n * <p>\r\n * The API consists of two main objects:\r\n * <dl>\r\n * <dt><b>{@link Paho.MQTT.Client}</b></dt>\r\n * <dd>This contains methods that provide the functionality of the API,\r\n * including provision of callbacks that notify the application when a message\r\n * arrives from or is delivered to the messaging server,\r\n * or when the status of its connection to the messaging server changes.</dd>\r\n * <dt><b>{@link Paho.MQTT.Message}</b></dt>\r\n * <dd>This encapsulates the payload of the message along with various attributes\r\n * associated with its delivery, in particular the destination to which it has\r\n * been (or is about to be) sent.</dd>\r\n * </dl>\r\n * <p>\r\n * The programming interface validates parameters passed to it, and will throw\r\n * an Error containing an error message intended for developer use, if it detects\r\n * an error with any parameter.\r\n * <p>\r\n * Example:\r\n *\r\n * <code><pre>\r\nclient = new Paho.MQTT.Client(location.hostname, Number(location.port), \"clientId\");\r\nclient.onConnectionLost = onConnectionLost;\r\nclient.onMessageArrived = onMessageArrived;\r\nclient.connect({onSuccess:onConnect});\r\n\r\nfunction onConnect() {\r\n  // Once a connection has been made, make a subscription and send a message.\r\n  console.log(\"onConnect\");\r\n  client.subscribe(\"/World\");\r\n  message = new Paho.MQTT.Message(\"Hello\");\r\n  message.destinationName = \"/World\";\r\n  client.send(message);\r\n};\r\nfunction onConnectionLost(responseObject) {\r\n  if (responseObject.errorCode !== 0)\r\n\tconsole.log(\"onConnectionLost:\"+responseObject.errorMessage);\r\n};\r\nfunction onMessageArrived(message) {\r\n  console.log(\"onMessageArrived:\"+message.payloadString);\r\n  client.disconnect();\r\n};\r\n * </pre></code>\r\n * @namespace Paho.MQTT\r\n */\nif (typeof Paho === \"undefined\") {\n  Paho = {};\n}\n\nPaho.MQTT = function (global) {\n  // Private variables below, these are only visible inside the function closure\n  // which is used to define the module.\n  var version = \"@VERSION@\";\n  var buildLevel = \"@BUILDLEVEL@\";\n  /**\r\n   * Unique message type identifiers, with associated\r\n   * associated integer values.\r\n   * @private\r\n   */\n\n  var MESSAGE_TYPE = {\n    CONNECT: 1,\n    CONNACK: 2,\n    PUBLISH: 3,\n    PUBACK: 4,\n    PUBREC: 5,\n    PUBREL: 6,\n    PUBCOMP: 7,\n    SUBSCRIBE: 8,\n    SUBACK: 9,\n    UNSUBSCRIBE: 10,\n    UNSUBACK: 11,\n    PINGREQ: 12,\n    PINGRESP: 13,\n    DISCONNECT: 14\n  }; // Collection of utility methods used to simplify module code\n  // and promote the DRY pattern.\n\n  /**\r\n   * Validate an object's parameter names to ensure they\r\n   * match a list of expected variables name for this option\r\n   * type. Used to ensure option object passed into the API don't\r\n   * contain erroneous parameters.\r\n   * @param {Object} obj - User options object\r\n   * @param {Object} keys - valid keys and types that may exist in obj.\r\n   * @throws {Error} Invalid option parameter found.\r\n   * @private\r\n   */\n\n  var validate = function (obj, keys) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (keys.hasOwnProperty(key)) {\n          if (typeof obj[key] !== keys[key]) throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\n        } else {\n          var errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\n\n          for (var key in keys) if (keys.hasOwnProperty(key)) errorStr = errorStr + \" \" + key;\n\n          throw new Error(errorStr);\n        }\n      }\n    }\n  };\n  /**\r\n   * Return a new function which runs the user function bound\r\n   * to a fixed scope.\r\n   * @param {function} User function\r\n   * @param {object} Function scope\r\n   * @return {function} User function bound to another scope\r\n   * @private\r\n   */\n\n\n  var scope = function (f, scope) {\n    return function () {\n      return f.apply(scope, arguments);\n    };\n  };\n  /**\r\n   * Unique message type identifiers, with associated\r\n   * associated integer values.\r\n   * @private\r\n   */\n\n\n  var ERROR = {\n    OK: {\n      code: 0,\n      text: \"AMQJSC0000I OK.\"\n    },\n    CONNECT_TIMEOUT: {\n      code: 1,\n      text: \"AMQJSC0001E Connect timed out.\"\n    },\n    SUBSCRIBE_TIMEOUT: {\n      code: 2,\n      text: \"AMQJS0002E Subscribe timed out.\"\n    },\n    UNSUBSCRIBE_TIMEOUT: {\n      code: 3,\n      text: \"AMQJS0003E Unsubscribe timed out.\"\n    },\n    PING_TIMEOUT: {\n      code: 4,\n      text: \"AMQJS0004E Ping timed out.\"\n    },\n    INTERNAL_ERROR: {\n      code: 5,\n      text: \"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\"\n    },\n    CONNACK_RETURNCODE: {\n      code: 6,\n      text: \"AMQJS0006E Bad Connack return code:{0} {1}.\"\n    },\n    SOCKET_ERROR: {\n      code: 7,\n      text: \"AMQJS0007E Socket error:{0}.\"\n    },\n    SOCKET_CLOSE: {\n      code: 8,\n      text: \"AMQJS0008I Socket closed.\"\n    },\n    MALFORMED_UTF: {\n      code: 9,\n      text: \"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"\n    },\n    UNSUPPORTED: {\n      code: 10,\n      text: \"AMQJS0010E {0} is not supported by this browser.\"\n    },\n    INVALID_STATE: {\n      code: 11,\n      text: \"AMQJS0011E Invalid state {0}.\"\n    },\n    INVALID_TYPE: {\n      code: 12,\n      text: \"AMQJS0012E Invalid type {0} for {1}.\"\n    },\n    INVALID_ARGUMENT: {\n      code: 13,\n      text: \"AMQJS0013E Invalid argument {0} for {1}.\"\n    },\n    UNSUPPORTED_OPERATION: {\n      code: 14,\n      text: \"AMQJS0014E Unsupported operation.\"\n    },\n    INVALID_STORED_DATA: {\n      code: 15,\n      text: \"AMQJS0015E Invalid data in local storage key={0} value={1}.\"\n    },\n    INVALID_MQTT_MESSAGE_TYPE: {\n      code: 16,\n      text: \"AMQJS0016E Invalid MQTT message type {0}.\"\n    },\n    MALFORMED_UNICODE: {\n      code: 17,\n      text: \"AMQJS0017E Malformed Unicode string:{0} {1}.\"\n    }\n  };\n  /** CONNACK RC Meaning. */\n\n  var CONNACK_RC = {\n    0: \"Connection Accepted\",\n    1: \"Connection Refused: unacceptable protocol version\",\n    2: \"Connection Refused: identifier rejected\",\n    3: \"Connection Refused: server unavailable\",\n    4: \"Connection Refused: bad user name or password\",\n    5: \"Connection Refused: not authorized\"\n  };\n  /**\r\n   * Format an error message text.\r\n   * @private\r\n   * @param {error} ERROR.KEY value above.\r\n   * @param {substitutions} [array] substituted into the text.\r\n   * @return the text with the substitutions made.\r\n   */\n\n  var format = function (error, substitutions) {\n    var text = error.text;\n\n    if (substitutions) {\n      var field, start;\n\n      for (var i = 0; i < substitutions.length; i++) {\n        field = \"{\" + i + \"}\";\n        start = text.indexOf(field);\n\n        if (start > 0) {\n          var part1 = text.substring(0, start);\n          var part2 = text.substring(start + field.length);\n          text = part1 + substitutions[i] + part2;\n        }\n      }\n    }\n\n    return text;\n  }; //MQTT protocol and version          6    M    Q    I    s    d    p    3\n\n\n  var MqttProtoIdentifierv3 = [0x00, 0x06, 0x4d, 0x51, 0x49, 0x73, 0x64, 0x70, 0x03]; //MQTT proto/version for 311         4    M    Q    T    T    4\n\n  var MqttProtoIdentifierv4 = [0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04];\n  /**\r\n   * Construct an MQTT wire protocol message.\r\n   * @param type MQTT packet type.\r\n   * @param options optional wire message attributes.\r\n   *\r\n   * Optional properties\r\n   *\r\n   * messageIdentifier: message ID in the range [0..65535]\r\n   * payloadMessage:\tApplication Message - PUBLISH only\r\n   * connectStrings:\tarray of 0 or more Strings to be put into the CONNECT payload\r\n   * topics:\t\t\tarray of strings (SUBSCRIBE, UNSUBSCRIBE)\r\n   * requestQoS:\t\tarray of QoS values [0..2]\r\n   *\r\n   * \"Flag\" properties\r\n   * cleanSession:\ttrue if present / false if absent (CONNECT)\r\n   * willMessage:  \ttrue if present / false if absent (CONNECT)\r\n   * isRetained:\t\ttrue if present / false if absent (CONNECT)\r\n   * userName:\t\ttrue if present / false if absent (CONNECT)\r\n   * password:\t\ttrue if present / false if absent (CONNECT)\r\n   * keepAliveInterval:\tinteger [0..65535]  (CONNECT)\r\n   *\r\n   * @private\r\n   * @ignore\r\n   */\n\n  var WireMessage = function (type, options) {\n    this.type = type;\n\n    for (var name in options) {\n      if (options.hasOwnProperty(name)) {\n        this[name] = options[name];\n      }\n    }\n  };\n\n  WireMessage.prototype.encode = function () {\n    // Compute the first byte of the fixed header\n    var first = (this.type & 0x0f) << 4;\n    /*\r\n     * Now calculate the length of the variable header + payload by adding up the lengths\r\n     * of all the component parts\r\n     */\n\n    var remLength = 0;\n    var topicStrLength = new Array();\n    var destinationNameLength = 0; // if the message contains a messageIdentifier then we need two bytes for that\n\n    if (this.messageIdentifier != undefined) remLength += 2;\n\n    switch (this.type) {\n      // If this a Connect then we need to include 12 bytes for its header\n      case MESSAGE_TYPE.CONNECT:\n        switch (this.mqttVersion) {\n          case 3:\n            remLength += MqttProtoIdentifierv3.length + 3;\n            break;\n\n          case 4:\n            remLength += MqttProtoIdentifierv4.length + 3;\n            break;\n        }\n\n        remLength += UTF8Length(this.clientId) + 2;\n\n        if (this.willMessage != undefined) {\n          remLength += UTF8Length(this.willMessage.destinationName) + 2; // Will message is always a string, sent as UTF-8 characters with a preceding length.\n\n          var willMessagePayloadBytes = this.willMessage.payloadBytes;\n          if (!(willMessagePayloadBytes instanceof Uint8Array)) willMessagePayloadBytes = new Uint8Array(payloadBytes);\n          remLength += willMessagePayloadBytes.byteLength + 2;\n        }\n\n        if (this.userName != undefined) remLength += UTF8Length(this.userName) + 2;\n        if (this.password != undefined) remLength += UTF8Length(this.password) + 2;\n        break;\n      // Subscribe, Unsubscribe can both contain topic strings\n\n      case MESSAGE_TYPE.SUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n\n        for (var i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = UTF8Length(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n\n        remLength += this.requestedQos.length; // 1 byte for each topic's Qos\n        // QoS on Subscribe only\n\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n\n        for (var i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = UTF8Length(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n\n        break;\n\n      case MESSAGE_TYPE.PUBREL:\n        first |= 0x02; // Qos = 1;\n\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        if (this.payloadMessage.duplicate) first |= 0x08;\n        first = first |= this.payloadMessage.qos << 1;\n        if (this.payloadMessage.retained) first |= 0x01;\n        destinationNameLength = UTF8Length(this.payloadMessage.destinationName);\n        remLength += destinationNameLength + 2;\n        var payloadBytes = this.payloadMessage.payloadBytes;\n        remLength += payloadBytes.byteLength;\n        if (payloadBytes instanceof ArrayBuffer) payloadBytes = new Uint8Array(payloadBytes);else if (!(payloadBytes instanceof Uint8Array)) payloadBytes = new Uint8Array(payloadBytes.buffer);\n        break;\n\n      case MESSAGE_TYPE.DISCONNECT:\n        break;\n\n      default:\n        ;\n    } // Now we can allocate a buffer for the message\n\n\n    var mbi = encodeMBI(remLength); // Convert the length to MQTT MBI format\n\n    var pos = mbi.length + 1; // Offset of start of variable header\n\n    var buffer = new ArrayBuffer(remLength + pos);\n    var byteStream = new Uint8Array(buffer); // view it as a sequence of bytes\n    //Write the fixed header into the buffer\n\n    byteStream[0] = first;\n    byteStream.set(mbi, 1); // If this is a PUBLISH then the variable header starts with a topic\n\n    if (this.type == MESSAGE_TYPE.PUBLISH) pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos); // If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\n    else if (this.type == MESSAGE_TYPE.CONNECT) {\n        switch (this.mqttVersion) {\n          case 3:\n            byteStream.set(MqttProtoIdentifierv3, pos);\n            pos += MqttProtoIdentifierv3.length;\n            break;\n\n          case 4:\n            byteStream.set(MqttProtoIdentifierv4, pos);\n            pos += MqttProtoIdentifierv4.length;\n            break;\n        }\n\n        var connectFlags = 0;\n        if (this.cleanSession) connectFlags = 0x02;\n\n        if (this.willMessage != undefined) {\n          connectFlags |= 0x04;\n          connectFlags |= this.willMessage.qos << 3;\n\n          if (this.willMessage.retained) {\n            connectFlags |= 0x20;\n          }\n        }\n\n        if (this.userName != undefined) connectFlags |= 0x80;\n        if (this.password != undefined) connectFlags |= 0x40;\n        byteStream[pos++] = connectFlags;\n        pos = writeUint16(this.keepAliveInterval, byteStream, pos);\n      } // Output the messageIdentifier - if there is one\n\n    if (this.messageIdentifier != undefined) pos = writeUint16(this.messageIdentifier, byteStream, pos);\n\n    switch (this.type) {\n      case MESSAGE_TYPE.CONNECT:\n        pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\n\n        if (this.willMessage != undefined) {\n          pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\n          pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n          byteStream.set(willMessagePayloadBytes, pos);\n          pos += willMessagePayloadBytes.byteLength;\n        }\n\n        if (this.userName != undefined) pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\n        if (this.password != undefined) pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        // PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\n        byteStream.set(payloadBytes, pos);\n        break;\n      //    \t    case MESSAGE_TYPE.PUBREC:\n      //    \t    case MESSAGE_TYPE.PUBREL:\n      //    \t    case MESSAGE_TYPE.PUBCOMP:\n      //    \t    \tbreak;\n\n      case MESSAGE_TYPE.SUBSCRIBE:\n        // SUBSCRIBE has a list of topic strings and request QoS\n        for (var i = 0; i < this.topics.length; i++) {\n          pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n          byteStream[pos++] = this.requestedQos[i];\n        }\n\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        // UNSUBSCRIBE has a list of topic strings\n        for (var i = 0; i < this.topics.length; i++) pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n\n        break;\n\n      default: // Do nothing.\n\n    }\n\n    return buffer;\n  };\n\n  function decodeMessage(input, pos) {\n    var startingPos = pos;\n    var first = input[pos];\n    var type = first >> 4;\n    var messageInfo = first &= 0x0f;\n    pos += 1; // Decode the remaining length (MBI format)\n\n    var digit;\n    var remLength = 0;\n    var multiplier = 1;\n\n    do {\n      if (pos == input.length) {\n        return [null, startingPos];\n      }\n\n      digit = input[pos++];\n      remLength += (digit & 0x7F) * multiplier;\n      multiplier *= 128;\n    } while ((digit & 0x80) != 0);\n\n    var endPos = pos + remLength;\n\n    if (endPos > input.length) {\n      return [null, startingPos];\n    }\n\n    var wireMessage = new WireMessage(type);\n\n    switch (type) {\n      case MESSAGE_TYPE.CONNACK:\n        var connectAcknowledgeFlags = input[pos++];\n        if (connectAcknowledgeFlags & 0x01) wireMessage.sessionPresent = true;\n        wireMessage.returnCode = input[pos++];\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        var qos = messageInfo >> 1 & 0x03;\n        var len = readUint16(input, pos);\n        pos += 2;\n        var topicName = parseUTF8(input, pos, len);\n        pos += len; // If QoS 1 or 2 there will be a messageIdentifier\n\n        if (qos > 0) {\n          wireMessage.messageIdentifier = readUint16(input, pos);\n          pos += 2;\n        }\n\n        var message = new Paho.MQTT.Message(input.subarray(pos, endPos));\n        if ((messageInfo & 0x01) == 0x01) message.retained = true;\n        if ((messageInfo & 0x08) == 0x08) message.duplicate = true;\n        message.qos = qos;\n        message.destinationName = topicName;\n        wireMessage.payloadMessage = message;\n        break;\n\n      case MESSAGE_TYPE.PUBACK:\n      case MESSAGE_TYPE.PUBREC:\n      case MESSAGE_TYPE.PUBREL:\n      case MESSAGE_TYPE.PUBCOMP:\n      case MESSAGE_TYPE.UNSUBACK:\n        wireMessage.messageIdentifier = readUint16(input, pos);\n        break;\n\n      case MESSAGE_TYPE.SUBACK:\n        wireMessage.messageIdentifier = readUint16(input, pos);\n        pos += 2;\n        wireMessage.returnCode = input.subarray(pos, endPos);\n        break;\n\n      default:\n        ;\n    }\n\n    return [wireMessage, endPos];\n  }\n\n  function writeUint16(input, buffer, offset) {\n    buffer[offset++] = input >> 8; //MSB\n\n    buffer[offset++] = input % 256; //LSB\n\n    return offset;\n  }\n\n  function writeString(input, utf8Length, buffer, offset) {\n    offset = writeUint16(utf8Length, buffer, offset);\n    stringToUTF8(input, buffer, offset);\n    return offset + utf8Length;\n  }\n\n  function readUint16(buffer, offset) {\n    return 256 * buffer[offset] + buffer[offset + 1];\n  }\n  /**\r\n   * Encodes an MQTT Multi-Byte Integer\r\n   * @private\r\n   */\n\n\n  function encodeMBI(number) {\n    var output = new Array(1);\n    var numBytes = 0;\n\n    do {\n      var digit = number % 128;\n      number = number >> 7;\n\n      if (number > 0) {\n        digit |= 0x80;\n      }\n\n      output[numBytes++] = digit;\n    } while (number > 0 && numBytes < 4);\n\n    return output;\n  }\n  /**\r\n   * Takes a String and calculates its length in bytes when encoded in UTF8.\r\n   * @private\r\n   */\n\n\n  function UTF8Length(input) {\n    var output = 0;\n\n    for (var i = 0; i < input.length; i++) {\n      var charCode = input.charCodeAt(i);\n\n      if (charCode > 0x7FF) {\n        // Surrogate pair means its a 4 byte character\n        if (0xD800 <= charCode && charCode <= 0xDBFF) {\n          i++;\n          output++;\n        }\n\n        output += 3;\n      } else if (charCode > 0x7F) output += 2;else output++;\n    }\n\n    return output;\n  }\n  /**\r\n   * Takes a String and writes it into an array as UTF8 encoded bytes.\r\n   * @private\r\n   */\n\n\n  function stringToUTF8(input, output, start) {\n    var pos = start;\n\n    for (var i = 0; i < input.length; i++) {\n      var charCode = input.charCodeAt(i); // Check for a surrogate pair.\n\n      if (0xD800 <= charCode && charCode <= 0xDBFF) {\n        var lowCharCode = input.charCodeAt(++i);\n\n        if (isNaN(lowCharCode)) {\n          throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\n        }\n\n        charCode = (charCode - 0xD800 << 10) + (lowCharCode - 0xDC00) + 0x10000;\n      }\n\n      if (charCode <= 0x7F) {\n        output[pos++] = charCode;\n      } else if (charCode <= 0x7FF) {\n        output[pos++] = charCode >> 6 & 0x1F | 0xC0;\n        output[pos++] = charCode & 0x3F | 0x80;\n      } else if (charCode <= 0xFFFF) {\n        output[pos++] = charCode >> 12 & 0x0F | 0xE0;\n        output[pos++] = charCode >> 6 & 0x3F | 0x80;\n        output[pos++] = charCode & 0x3F | 0x80;\n      } else {\n        output[pos++] = charCode >> 18 & 0x07 | 0xF0;\n        output[pos++] = charCode >> 12 & 0x3F | 0x80;\n        output[pos++] = charCode >> 6 & 0x3F | 0x80;\n        output[pos++] = charCode & 0x3F | 0x80;\n      }\n\n      ;\n    }\n\n    return output;\n  }\n\n  function parseUTF8(input, offset, length) {\n    var output = \"\";\n    var utf16;\n    var pos = offset;\n\n    while (pos < offset + length) {\n      var byte1 = input[pos++];\n      if (byte1 < 128) utf16 = byte1;else {\n        var byte2 = input[pos++] - 128;\n        if (byte2 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), \"\"]));\n        if (byte1 < 0xE0) // 2 byte character\n          utf16 = 64 * (byte1 - 0xC0) + byte2;else {\n          var byte3 = input[pos++] - 128;\n          if (byte3 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\n          if (byte1 < 0xF0) // 3 byte character\n            utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;else {\n            var byte4 = input[pos++] - 128;\n            if (byte4 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n            if (byte1 < 0xF8) // 4 byte character\n              utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;else // longer encodings are not supported\n              throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n          }\n        }\n      }\n\n      if (utf16 > 0xFFFF) // 4 byte character - express as a surrogate pair\n        {\n          utf16 -= 0x10000;\n          output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\n\n          utf16 = 0xDC00 + (utf16 & 0x3FF); // trail character\n        }\n\n      output += String.fromCharCode(utf16);\n    }\n\n    return output;\n  }\n  /**\r\n   * Repeat keepalive requests, monitor responses.\r\n   * @ignore\r\n   */\n\n\n  var Pinger = function (client, window, keepAliveInterval) {\n    this._client = client;\n    this._window = window;\n    this._keepAliveInterval = keepAliveInterval * 1000;\n    this.isReset = false;\n    var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\n\n    var doTimeout = function (pinger) {\n      return function () {\n        return doPing.apply(pinger);\n      };\n    };\n    /** @ignore */\n\n\n    var doPing = function () {\n      if (!this.isReset) {\n        this._client._trace(\"Pinger.doPing\", \"Timed out\");\n\n        this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));\n      } else {\n        this.isReset = false;\n\n        this._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\n\n        this._client.socket.send(pingReq);\n\n        this.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\n      }\n    };\n\n    this.reset = function () {\n      this.isReset = true;\n\n      this._window.clearTimeout(this.timeout);\n\n      if (this._keepAliveInterval > 0) this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n    };\n\n    this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  };\n  /**\r\n   * Monitor request completion.\r\n   * @ignore\r\n   */\n\n\n  var Timeout = function (client, window, timeoutSeconds, action, args) {\n    this._window = window;\n    if (!timeoutSeconds) timeoutSeconds = 30;\n\n    var doTimeout = function (action, client, args) {\n      return function () {\n        return action.apply(client, args);\n      };\n    };\n\n    this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\n\n    this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  };\n  /*\r\n   * Internal implementation of the Websockets MQTT V3.1 client.\r\n   *\r\n   * @name Paho.MQTT.ClientImpl @constructor\r\n   * @param {String} host the DNS nameof the webSocket host.\r\n   * @param {Number} port the port number for that host.\r\n   * @param {String} clientId the MQ client identifier.\r\n   */\n\n\n  var ClientImpl = function (uri, host, port, path, clientId) {\n    // Check dependencies are satisfied in this browser.\n    if (!(\"WebSocket\" in global && global[\"WebSocket\"] !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\n    }\n\n    if (!(\"localStorage\" in global && global[\"localStorage\"] !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\n    }\n\n    if (!(\"ArrayBuffer\" in global && global[\"ArrayBuffer\"] !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\n    }\n\n    this._trace(\"Paho.MQTT.Client\", uri, host, port, path, clientId);\n\n    this.host = host;\n    this.port = port;\n    this.path = path;\n    this.uri = uri;\n    this.clientId = clientId; // Local storagekeys are qualified with the following string.\n    // The conditional inclusion of path in the key is for backward\n    // compatibility to when the path was not configurable and assumed to\n    // be /mqtt\n\n    this._localKey = host + \":\" + port + (path != \"/mqtt\" ? \":\" + path : \"\") + \":\" + clientId + \":\"; // Create private instance-only message queue\n    // Internal queue of messages to be sent, in sending order.\n\n    this._msg_queue = []; // Messages we have sent and are expecting a response for, indexed by their respective message ids.\n\n    this._sentMessages = {}; // Messages we have received and acknowleged and are expecting a confirm message for\n    // indexed by their respective message ids.\n\n    this._receivedMessages = {}; // Internal list of callbacks to be executed when messages\n    // have been successfully sent over web socket, e.g. disconnect\n    // when it doesn't have to wait for ACK, just message is dispatched.\n\n    this._notify_msg_sent = {}; // Unique identifier for SEND messages, incrementing\n    // counter as messages are sent.\n\n    this._message_identifier = 1; // Used to determine the transmission sequence of stored sent messages.\n\n    this._sequence = 0; // Load the local state, if any, from the saved version, only restore state relevant to this client.\n\n    for (var key in localStorage) if (key.indexOf(\"Sent:\" + this._localKey) == 0 || key.indexOf(\"Received:\" + this._localKey) == 0) this.restore(key);\n  }; // Messaging Client public instance members.\n\n\n  ClientImpl.prototype.host;\n  ClientImpl.prototype.port;\n  ClientImpl.prototype.path;\n  ClientImpl.prototype.uri;\n  ClientImpl.prototype.clientId; // Messaging Client private instance members.\n\n  ClientImpl.prototype.socket;\n  /* true once we have received an acknowledgement to a CONNECT packet. */\n\n  ClientImpl.prototype.connected = false;\n  /* The largest message identifier allowed, may not be larger than 2**16 but\r\n   * if set smaller reduces the maximum number of outbound messages allowed.\r\n   */\n\n  ClientImpl.prototype.maxMessageIdentifier = 65536;\n  ClientImpl.prototype.connectOptions;\n  ClientImpl.prototype.hostIndex;\n  ClientImpl.prototype.onConnectionLost;\n  ClientImpl.prototype.onMessageDelivered;\n  ClientImpl.prototype.onMessageArrived;\n  ClientImpl.prototype.traceFunction;\n  ClientImpl.prototype._msg_queue = null;\n  ClientImpl.prototype._connectTimeout;\n  /* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\n\n  ClientImpl.prototype.sendPinger = null;\n  /* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\n\n  ClientImpl.prototype.receivePinger = null;\n  ClientImpl.prototype.receiveBuffer = null;\n  ClientImpl.prototype._traceBuffer = null;\n  ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\n\n  ClientImpl.prototype.connect = function (connectOptions) {\n    var connectOptionsMasked = this._traceMask(connectOptions, \"password\");\n\n    this._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\n\n    if (this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n    if (this.socket) throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n    this.connectOptions = connectOptions;\n\n    if (connectOptions.uris) {\n      this.hostIndex = 0;\n\n      this._doConnect(connectOptions.uris[0]);\n    } else {\n      this._doConnect(this.uri);\n    }\n  };\n\n  ClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\n    this._trace(\"Client.subscribe\", filter, subscribeOptions);\n\n    if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n    wireMessage.topics = [filter];\n    if (subscribeOptions.qos != undefined) wireMessage.requestedQos = [subscribeOptions.qos];else wireMessage.requestedQos = [0];\n\n    if (subscribeOptions.onSuccess) {\n      wireMessage.onSuccess = function (grantedQos) {\n        subscribeOptions.onSuccess({\n          invocationContext: subscribeOptions.invocationContext,\n          grantedQos: grantedQos\n        });\n      };\n    }\n\n    if (subscribeOptions.onFailure) {\n      wireMessage.onFailure = function (errorCode) {\n        subscribeOptions.onFailure({\n          invocationContext: subscribeOptions.invocationContext,\n          errorCode: errorCode\n        });\n      };\n    }\n\n    if (subscribeOptions.timeout) {\n      wireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure, [{\n        invocationContext: subscribeOptions.invocationContext,\n        errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,\n        errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)\n      }]);\n    } // All subscriptions return a SUBACK.\n\n\n    this._requires_ack(wireMessage);\n\n    this._schedule_message(wireMessage);\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype.unsubscribe = function (filter, unsubscribeOptions) {\n    this._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\n\n    if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n    wireMessage.topics = [filter];\n\n    if (unsubscribeOptions.onSuccess) {\n      wireMessage.callback = function () {\n        unsubscribeOptions.onSuccess({\n          invocationContext: unsubscribeOptions.invocationContext\n        });\n      };\n    }\n\n    if (unsubscribeOptions.timeout) {\n      wireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure, [{\n        invocationContext: unsubscribeOptions.invocationContext,\n        errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,\n        errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)\n      }]);\n    } // All unsubscribes return a SUBACK.\n\n\n    this._requires_ack(wireMessage);\n\n    this._schedule_message(wireMessage);\n  };\n\n  ClientImpl.prototype.send = function (message) {\n    this._trace(\"Client.send\", message);\n\n    if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\n    wireMessage.payloadMessage = message;\n    if (message.qos > 0) this._requires_ack(wireMessage);else if (this.onMessageDelivered) this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\n\n    this._schedule_message(wireMessage);\n  };\n\n  ClientImpl.prototype.disconnect = function () {\n    this._trace(\"Client.disconnect\");\n\n    if (!this.socket) throw new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\n    wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT); // Run the disconnected call back as soon as the message has been sent,\n    // in case of a failure later on in the disconnect processing.\n    // as a consequence, the _disconected call back may be run several times.\n\n    this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\n\n    this._schedule_message(wireMessage);\n  };\n\n  ClientImpl.prototype.getTraceLog = function () {\n    if (this._traceBuffer !== null) {\n      this._trace(\"Client.getTraceLog\", new Date());\n\n      this._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\n\n      for (var key in this._sentMessages) this._trace(\"_sentMessages \", key, this._sentMessages[key]);\n\n      for (var key in this._receivedMessages) this._trace(\"_receivedMessages \", key, this._receivedMessages[key]);\n\n      return this._traceBuffer;\n    }\n  };\n\n  ClientImpl.prototype.startTrace = function () {\n    if (this._traceBuffer === null) {\n      this._traceBuffer = [];\n    }\n\n    this._trace(\"Client.startTrace\", new Date(), version);\n  };\n\n  ClientImpl.prototype.stopTrace = function () {\n    delete this._traceBuffer;\n  };\n\n  ClientImpl.prototype._doConnect = function (wsurl) {\n    // When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\n    if (this.connectOptions.useSSL) {\n      var uriParts = wsurl.split(\":\");\n      uriParts[0] = \"wss\";\n      wsurl = uriParts.join(\":\");\n    }\n\n    this.connected = false;\n\n    if (this.connectOptions.mqttVersion < 4) {\n      this.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\n    } else {\n      this.socket = new WebSocket(wsurl, [\"mqtt\"]);\n    }\n\n    this.socket.binaryType = 'arraybuffer';\n    this.socket.onopen = scope(this._on_socket_open, this);\n    this.socket.onmessage = scope(this._on_socket_message, this);\n    this.socket.onerror = scope(this._on_socket_error, this);\n    this.socket.onclose = scope(this._on_socket_close, this);\n    this.sendPinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n    this.receivePinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n    this._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\n  }; // Schedule a new message to be sent over the WebSockets\n  // connection. CONNECT messages cause WebSocket connection\n  // to be started. All other messages are queued internally\n  // until this has happened. When WS connection starts, process\n  // all outstanding messages.\n\n\n  ClientImpl.prototype._schedule_message = function (message) {\n    this._msg_queue.push(message); // Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\n\n\n    if (this.connected) {\n      this._process_queue();\n    }\n  };\n\n  ClientImpl.prototype.store = function (prefix, wireMessage) {\n    var storedMessage = {\n      type: wireMessage.type,\n      messageIdentifier: wireMessage.messageIdentifier,\n      version: 1\n    };\n\n    switch (wireMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        if (wireMessage.pubRecReceived) storedMessage.pubRecReceived = true; // Convert the payload to a hex string.\n\n        storedMessage.payloadMessage = {};\n        var hex = \"\";\n        var messageBytes = wireMessage.payloadMessage.payloadBytes;\n\n        for (var i = 0; i < messageBytes.length; i++) {\n          if (messageBytes[i] <= 0xF) hex = hex + \"0\" + messageBytes[i].toString(16);else hex = hex + messageBytes[i].toString(16);\n        }\n\n        storedMessage.payloadMessage.payloadHex = hex;\n        storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\n        storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\n        if (wireMessage.payloadMessage.duplicate) storedMessage.payloadMessage.duplicate = true;\n        if (wireMessage.payloadMessage.retained) storedMessage.payloadMessage.retained = true; // Add a sequence number to sent messages.\n\n        if (prefix.indexOf(\"Sent:\") == 0) {\n          if (wireMessage.sequence === undefined) wireMessage.sequence = ++this._sequence;\n          storedMessage.sequence = wireMessage.sequence;\n        }\n\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\n    }\n\n    localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));\n  };\n\n  ClientImpl.prototype.restore = function (key) {\n    var value = localStorage.getItem(key);\n    var storedMessage = JSON.parse(value);\n    var wireMessage = new WireMessage(storedMessage.type, storedMessage);\n\n    switch (storedMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        // Replace the payload message with a Message object.\n        var hex = storedMessage.payloadMessage.payloadHex;\n        var buffer = new ArrayBuffer(hex.length / 2);\n        var byteStream = new Uint8Array(buffer);\n        var i = 0;\n\n        while (hex.length >= 2) {\n          var x = parseInt(hex.substring(0, 2), 16);\n          hex = hex.substring(2, hex.length);\n          byteStream[i++] = x;\n        }\n\n        var payloadMessage = new Paho.MQTT.Message(byteStream);\n        payloadMessage.qos = storedMessage.payloadMessage.qos;\n        payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n        if (storedMessage.payloadMessage.duplicate) payloadMessage.duplicate = true;\n        if (storedMessage.payloadMessage.retained) payloadMessage.retained = true;\n        wireMessage.payloadMessage = payloadMessage;\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n    }\n\n    if (key.indexOf(\"Sent:\" + this._localKey) == 0) {\n      wireMessage.payloadMessage.duplicate = true;\n      this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n    } else if (key.indexOf(\"Received:\" + this._localKey) == 0) {\n      this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n    }\n  };\n\n  ClientImpl.prototype._process_queue = function () {\n    var message = null; // Process messages in order they were added\n\n    var fifo = this._msg_queue.reverse(); // Send all queued messages down socket connection\n\n\n    while (message = fifo.pop()) {\n      this._socket_send(message); // Notify listeners that message was successfully sent\n\n\n      if (this._notify_msg_sent[message]) {\n        this._notify_msg_sent[message]();\n\n        delete this._notify_msg_sent[message];\n      }\n    }\n  };\n  /**\r\n   * Expect an ACK response for this message. Add message to the set of in progress\r\n   * messages and set an unused identifier in this message.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._requires_ack = function (wireMessage) {\n    var messageCount = Object.keys(this._sentMessages).length;\n    if (messageCount > this.maxMessageIdentifier) throw Error(\"Too many messages:\" + messageCount);\n\n    while (this._sentMessages[this._message_identifier] !== undefined) {\n      this._message_identifier++;\n    }\n\n    wireMessage.messageIdentifier = this._message_identifier;\n    this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\n    if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\n      this.store(\"Sent:\", wireMessage);\n    }\n\n    if (this._message_identifier === this.maxMessageIdentifier) {\n      this._message_identifier = 1;\n    }\n  };\n  /**\r\n   * Called when the underlying websocket has been opened.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._on_socket_open = function () {\n    // Create the CONNECT message object.\n    var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\n    wireMessage.clientId = this.clientId;\n\n    this._socket_send(wireMessage);\n  };\n  /**\r\n   * Called when the underlying websocket has received a complete packet.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._on_socket_message = function (event) {\n    this._trace(\"Client._on_socket_message\", event.data); // Reset the receive ping timer, we now have evidence the server is alive.\n\n\n    this.receivePinger.reset();\n\n    var messages = this._deframeMessages(event.data);\n\n    for (var i = 0; i < messages.length; i += 1) {\n      this._handleMessage(messages[i]);\n    }\n  };\n\n  ClientImpl.prototype._deframeMessages = function (data) {\n    var byteArray = new Uint8Array(data);\n\n    if (this.receiveBuffer) {\n      var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);\n      newData.set(this.receiveBuffer);\n      newData.set(byteArray, this.receiveBuffer.length);\n      byteArray = newData;\n      delete this.receiveBuffer;\n    }\n\n    try {\n      var offset = 0;\n      var messages = [];\n\n      while (offset < byteArray.length) {\n        var result = decodeMessage(byteArray, offset);\n        var wireMessage = result[0];\n        offset = result[1];\n\n        if (wireMessage !== null) {\n          messages.push(wireMessage);\n        } else {\n          break;\n        }\n      }\n\n      if (offset < byteArray.length) {\n        this.receiveBuffer = byteArray.subarray(offset);\n      }\n    } catch (error) {\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n\n      return;\n    }\n\n    return messages;\n  };\n\n  ClientImpl.prototype._handleMessage = function (wireMessage) {\n    this._trace(\"Client._handleMessage\", wireMessage);\n\n    try {\n      switch (wireMessage.type) {\n        case MESSAGE_TYPE.CONNACK:\n          this._connectTimeout.cancel(); // If we have started using clean session then clear up the local state.\n\n\n          if (this.connectOptions.cleanSession) {\n            for (var key in this._sentMessages) {\n              var sentMessage = this._sentMessages[key];\n              localStorage.removeItem(\"Sent:\" + this._localKey + sentMessage.messageIdentifier);\n            }\n\n            this._sentMessages = {};\n\n            for (var key in this._receivedMessages) {\n              var receivedMessage = this._receivedMessages[key];\n              localStorage.removeItem(\"Received:\" + this._localKey + receivedMessage.messageIdentifier);\n            }\n\n            this._receivedMessages = {};\n          } // Client connected and ready for business.\n\n\n          if (wireMessage.returnCode === 0) {\n            this.connected = true; // Jump to the end of the list of uris and stop looking for a good host.\n\n            if (this.connectOptions.uris) this.hostIndex = this.connectOptions.uris.length;\n          } else {\n            this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n\n            break;\n          } // Resend messages.\n\n\n          var sequencedMessages = new Array();\n\n          for (var msgId in this._sentMessages) {\n            if (this._sentMessages.hasOwnProperty(msgId)) sequencedMessages.push(this._sentMessages[msgId]);\n          } // Sort sentMessages into the original sent order.\n\n\n          var sequencedMessages = sequencedMessages.sort(function (a, b) {\n            return a.sequence - b.sequence;\n          });\n\n          for (var i = 0, len = sequencedMessages.length; i < len; i++) {\n            var sentMessage = sequencedMessages[i];\n\n            if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\n              var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {\n                messageIdentifier: sentMessage.messageIdentifier\n              });\n\n              this._schedule_message(pubRelMessage);\n            } else {\n              this._schedule_message(sentMessage);\n            }\n\n            ;\n          } // Execute the connectOptions.onSuccess callback if there is one.\n\n\n          if (this.connectOptions.onSuccess) {\n            this.connectOptions.onSuccess({\n              invocationContext: this.connectOptions.invocationContext\n            });\n          } // Process all queued messages now that the connection is established.\n\n\n          this._process_queue();\n\n          break;\n\n        case MESSAGE_TYPE.PUBLISH:\n          this._receivePublish(wireMessage);\n\n          break;\n\n        case MESSAGE_TYPE.PUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier]; // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n\n          if (sentMessage) {\n            delete this._sentMessages[wireMessage.messageIdentifier];\n            localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\n            if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PUBREC:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier]; // If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n\n          if (sentMessage) {\n            sentMessage.pubRecReceived = true;\n            var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {\n              messageIdentifier: wireMessage.messageIdentifier\n            });\n            this.store(\"Sent:\", sentMessage);\n\n            this._schedule_message(pubRelMessage);\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PUBREL:\n          var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\n          localStorage.removeItem(\"Received:\" + this._localKey + wireMessage.messageIdentifier); // If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n\n          if (receivedMessage) {\n            this._receiveMessage(receivedMessage);\n\n            delete this._receivedMessages[wireMessage.messageIdentifier];\n          } // Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n\n\n          var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {\n            messageIdentifier: wireMessage.messageIdentifier\n          });\n\n          this._schedule_message(pubCompMessage);\n\n          break;\n\n        case MESSAGE_TYPE.PUBCOMP:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n          delete this._sentMessages[wireMessage.messageIdentifier];\n          localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\n          if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);\n          break;\n\n        case MESSAGE_TYPE.SUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\n          if (sentMessage) {\n            if (sentMessage.timeOut) sentMessage.timeOut.cancel(); // This will need to be fixed when we add multiple topic support\n\n            if (wireMessage.returnCode[0] === 0x80) {\n              if (sentMessage.onFailure) {\n                sentMessage.onFailure(wireMessage.returnCode);\n              }\n            } else if (sentMessage.onSuccess) {\n              sentMessage.onSuccess(wireMessage.returnCode);\n            }\n\n            delete this._sentMessages[wireMessage.messageIdentifier];\n          }\n\n          break;\n\n        case MESSAGE_TYPE.UNSUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\n          if (sentMessage) {\n            if (sentMessage.timeOut) sentMessage.timeOut.cancel();\n\n            if (sentMessage.callback) {\n              sentMessage.callback();\n            }\n\n            delete this._sentMessages[wireMessage.messageIdentifier];\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PINGRESP:\n          /* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\n          this.sendPinger.reset();\n          break;\n\n        case MESSAGE_TYPE.DISCONNECT:\n          // Clients do not expect to receive disconnect packets.\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n          break;\n\n        default:\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n      }\n\n      ;\n    } catch (error) {\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n\n      return;\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._on_socket_error = function (error) {\n    this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._on_socket_close = function () {\n    this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._socket_send = function (wireMessage) {\n    if (wireMessage.type == 1) {\n      var wireMessageMasked = this._traceMask(wireMessage, \"password\");\n\n      this._trace(\"Client._socket_send\", wireMessageMasked);\n    } else this._trace(\"Client._socket_send\", wireMessage);\n\n    this.socket.send(wireMessage.encode());\n    /* We have proved to the server we are alive. */\n\n    this.sendPinger.reset();\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._receivePublish = function (wireMessage) {\n    switch (wireMessage.payloadMessage.qos) {\n      case \"undefined\":\n      case 0:\n        this._receiveMessage(wireMessage);\n\n        break;\n\n      case 1:\n        var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {\n          messageIdentifier: wireMessage.messageIdentifier\n        });\n\n        this._schedule_message(pubAckMessage);\n\n        this._receiveMessage(wireMessage);\n\n        break;\n\n      case 2:\n        this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n        this.store(\"Received:\", wireMessage);\n        var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {\n          messageIdentifier: wireMessage.messageIdentifier\n        });\n\n        this._schedule_message(pubRecMessage);\n\n        break;\n\n      default:\n        throw Error(\"Invaild qos=\" + wireMmessage.payloadMessage.qos);\n    }\n\n    ;\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._receiveMessage = function (wireMessage) {\n    if (this.onMessageArrived) {\n      this.onMessageArrived(wireMessage.payloadMessage);\n    }\n  };\n  /**\r\n   * Client has disconnected either at its own request or because the server\r\n   * or network disconnected it. Remove all non-durable state.\r\n   * @param {errorCode} [number] the error number.\r\n   * @param {errorText} [string] the error text.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._disconnected = function (errorCode, errorText) {\n    this._trace(\"Client._disconnected\", errorCode, errorText);\n\n    this.sendPinger.cancel();\n    this.receivePinger.cancel();\n    if (this._connectTimeout) this._connectTimeout.cancel(); // Clear message buffers.\n\n    this._msg_queue = [];\n    this._notify_msg_sent = {};\n\n    if (this.socket) {\n      // Cancel all socket callbacks so that they cannot be driven again by this socket.\n      this.socket.onopen = null;\n      this.socket.onmessage = null;\n      this.socket.onerror = null;\n      this.socket.onclose = null;\n      if (this.socket.readyState === 1) this.socket.close();\n      delete this.socket;\n    }\n\n    if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {\n      // Try the next host.\n      this.hostIndex++;\n\n      this._doConnect(this.connectOptions.uris[this.hostIndex]);\n    } else {\n      if (errorCode === undefined) {\n        errorCode = ERROR.OK.code;\n        errorText = format(ERROR.OK);\n      } // Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n\n\n      if (this.connected) {\n        this.connected = false; // Execute the connectionLostCallback if there is one, and we were connected.\n\n        if (this.onConnectionLost) this.onConnectionLost({\n          errorCode: errorCode,\n          errorMessage: errorText\n        });\n      } else {\n        // Otherwise we never had a connection, so indicate that the connect has failed.\n        if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\n          this._trace(\"Failed to connect V4, dropping back to V3\");\n\n          this.connectOptions.mqttVersion = 3;\n\n          if (this.connectOptions.uris) {\n            this.hostIndex = 0;\n\n            this._doConnect(this.connectOptions.uris[0]);\n          } else {\n            this._doConnect(this.uri);\n          }\n        } else if (this.connectOptions.onFailure) {\n          this.connectOptions.onFailure({\n            invocationContext: this.connectOptions.invocationContext,\n            errorCode: errorCode,\n            errorMessage: errorText\n          });\n        }\n      }\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._trace = function () {\n    // Pass trace message back to client's callback function\n    if (this.traceFunction) {\n      for (var i in arguments) {\n        if (typeof arguments[i] !== \"undefined\") arguments[i] = JSON.stringify(arguments[i]);\n      }\n\n      var record = Array.prototype.slice.call(arguments).join(\"\");\n      this.traceFunction({\n        severity: \"Debug\",\n        message: record\n      });\n    } //buffer style trace\n\n\n    if (this._traceBuffer !== null) {\n      for (var i = 0, max = arguments.length; i < max; i++) {\n        if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {\n          this._traceBuffer.shift();\n        }\n\n        if (i === 0) this._traceBuffer.push(arguments[i]);else if (typeof arguments[i] === \"undefined\") this._traceBuffer.push(arguments[i]);else this._traceBuffer.push(\"  \" + JSON.stringify(arguments[i]));\n      }\n\n      ;\n    }\n\n    ;\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._traceMask = function (traceObject, masked) {\n    var traceObjectMasked = {};\n\n    for (var attr in traceObject) {\n      if (traceObject.hasOwnProperty(attr)) {\n        if (attr == masked) traceObjectMasked[attr] = \"******\";else traceObjectMasked[attr] = traceObject[attr];\n      }\n    }\n\n    return traceObjectMasked;\n  }; // ------------------------------------------------------------------------\n  // Public Programming interface.\n  // ------------------------------------------------------------------------\n\n  /**\r\n   * The JavaScript application communicates to the server using a {@link Paho.MQTT.Client} object.\r\n   * <p>\r\n   * Most applications will create just one Client object and then call its connect() method,\r\n   * however applications can create more than one Client object if they wish.\r\n   * In this case the combination of host, port and clientId attributes must be different for each Client object.\r\n   * <p>\r\n   * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\r\n   * (even though the underlying protocol exchange might be synchronous in nature).\r\n   * This means they signal their completion by calling back to the application,\r\n   * via Success or Failure callback functions provided by the application on the method in question.\r\n   * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\r\n   * of the script that made the invocation.\r\n   * <p>\r\n   * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\r\n   * that are defined on the {@link Paho.MQTT.Client} object.\r\n   * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\r\n   *\r\n   * @name Paho.MQTT.Client\r\n   *\r\n   * @constructor\r\n   *\r\n   * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\r\n   * @param {number} port - the port number to connect to - only required if host is not a URI\r\n   * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\r\n   * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\r\n   *\r\n   * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\r\n   * @property {number} port - <i>read only</i> the server's port.\r\n   * @property {string} path - <i>read only</i> the server's path.\r\n   * @property {string} clientId - <i>read only</i> used when connecting to the server.\r\n   * @property {function} onConnectionLost - called when a connection has been lost.\r\n   *                            after a connect() method has succeeded.\r\n   *                            Establish the call back used when a connection has been lost. The connection may be\r\n   *                            lost because the client initiates a disconnect or because the server or network\r\n   *                            cause the client to be disconnected. The disconnect call back may be called without\r\n   *                            the connectionComplete call back being invoked if, for example the client fails to\r\n   *                            connect.\r\n   *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\r\n   *                            <ol>\r\n   *                            <li>errorCode\r\n   *                            <li>errorMessage\r\n   *                            </ol>\r\n   * @property {function} onMessageDelivered called when a message has been delivered.\r\n   *                            All processing that this Client will ever do has been completed. So, for example,\r\n   *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\r\n   *                            and the message has been removed from persistent storage before this callback is invoked.\r\n   *                            Parameters passed to the onMessageDelivered callback are:\r\n   *                            <ol>\r\n   *                            <li>{@link Paho.MQTT.Message} that was delivered.\r\n   *                            </ol>\r\n   * @property {function} onMessageArrived called when a message has arrived in this Paho.MQTT.client.\r\n   *                            Parameters passed to the onMessageArrived callback are:\r\n   *                            <ol>\r\n   *                            <li>{@link Paho.MQTT.Message} that has arrived.\r\n   *                            </ol>\r\n   */\n\n\n  var Client = function (host, port, path, clientId) {\n    var uri;\n    if (typeof host !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\n\n    if (arguments.length == 2) {\n      // host: must be full ws:// uri\n      // port: clientId\n      clientId = port;\n      uri = host;\n      var match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\n\n      if (match) {\n        host = match[4] || match[2];\n        port = parseInt(match[7]);\n        path = match[8];\n      } else {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [host, \"host\"]));\n      }\n    } else {\n      if (arguments.length == 3) {\n        clientId = path;\n        path = \"/mqtt\";\n      }\n\n      if (typeof port !== \"number\" || port < 0) throw new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\n      if (typeof path !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [typeof path, \"path\"]));\n      var ipv6AddSBracket = host.indexOf(\":\") != -1 && host.slice(0, 1) != \"[\" && host.slice(-1) != \"]\";\n      uri = \"ws://\" + (ipv6AddSBracket ? \"[\" + host + \"]\" : host) + \":\" + port + path;\n    }\n\n    var clientIdLength = 0;\n\n    for (var i = 0; i < clientId.length; i++) {\n      var charCode = clientId.charCodeAt(i);\n\n      if (0xD800 <= charCode && charCode <= 0xDBFF) {\n        i++; // Surrogate pair.\n      }\n\n      clientIdLength++;\n    }\n\n    if (typeof clientId !== \"string\" || clientIdLength > 65535) throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\n    var client = new ClientImpl(uri, host, port, path, clientId);\n\n    this._getHost = function () {\n      return host;\n    };\n\n    this._setHost = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getPort = function () {\n      return port;\n    };\n\n    this._setPort = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getPath = function () {\n      return path;\n    };\n\n    this._setPath = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getURI = function () {\n      return uri;\n    };\n\n    this._setURI = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getClientId = function () {\n      return client.clientId;\n    };\n\n    this._setClientId = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getOnConnectionLost = function () {\n      return client.onConnectionLost;\n    };\n\n    this._setOnConnectionLost = function (newOnConnectionLost) {\n      if (typeof newOnConnectionLost === \"function\") client.onConnectionLost = newOnConnectionLost;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\n    };\n\n    this._getOnMessageDelivered = function () {\n      return client.onMessageDelivered;\n    };\n\n    this._setOnMessageDelivered = function (newOnMessageDelivered) {\n      if (typeof newOnMessageDelivered === \"function\") client.onMessageDelivered = newOnMessageDelivered;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\n    };\n\n    this._getOnMessageArrived = function () {\n      return client.onMessageArrived;\n    };\n\n    this._setOnMessageArrived = function (newOnMessageArrived) {\n      if (typeof newOnMessageArrived === \"function\") client.onMessageArrived = newOnMessageArrived;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\n    };\n\n    this._getTrace = function () {\n      return client.traceFunction;\n    };\n\n    this._setTrace = function (trace) {\n      if (typeof trace === \"function\") {\n        client.traceFunction = trace;\n      } else {\n        throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, \"onTrace\"]));\n      }\n    };\n    /**\r\n     * Connect this Messaging client to its server.\r\n     *\r\n     * @name Paho.MQTT.Client#connect\r\n     * @function\r\n     * @param {Object} connectOptions - attributes used with the connection.\r\n     * @param {number} connectOptions.timeout - If the connect has not succeeded within this\r\n     *                    number of seconds, it is deemed to have failed.\r\n     *                    The default is 30 seconds.\r\n     * @param {string} connectOptions.userName - Authentication username for this connection.\r\n     * @param {string} connectOptions.password - Authentication password for this connection.\r\n     * @param {Paho.MQTT.Message} connectOptions.willMessage - sent by the server when the client\r\n     *                    disconnects abnormally.\r\n     * @param {Number} connectOptions.keepAliveInterval - the server disconnects this client if\r\n     *                    there is no activity for this number of seconds.\r\n     *                    The default value of 60 seconds is assumed if not set.\r\n     * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\r\n     *                    persistent state is deleted on successful connect.\r\n     * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\r\n     * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\r\n     * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\r\n     *                    has been received from the server.\r\n     * A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n     * <ol>\r\n     * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\r\n     * </ol>\r\n     * @config {function} [onFailure] called when the connect request has failed or timed out.\r\n     * A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     * <ol>\r\n     * <li>invocationContext as passed in to the onFailure method in the connectOptions.\r\n     * <li>errorCode a number indicating the nature of the error.\r\n     * <li>errorMessage text describing the error.\r\n     * </ol>\r\n     * @config {Array} [hosts] If present this contains either a set of hostnames or fully qualified\r\n     * WebSocket URIs (ws://example.com:1883/mqtt), that are tried in order in place\r\n     * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\r\n     * one of then succeeds.\r\n     * @config {Array} [ports] If present the set of ports matching the hosts. If hosts contains URIs, this property\r\n     * is not used.\r\n     * @throws {InvalidState} if the client is not in disconnected state. The client must have received connectionLost\r\n     * or disconnected before calling connect for a second or subsequent time.\r\n     */\n\n\n    this.connect = function (connectOptions) {\n      connectOptions = connectOptions || {};\n      validate(connectOptions, {\n        timeout: \"number\",\n        userName: \"string\",\n        password: \"string\",\n        willMessage: \"object\",\n        keepAliveInterval: \"number\",\n        cleanSession: \"boolean\",\n        useSSL: \"boolean\",\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        hosts: \"object\",\n        ports: \"object\",\n        mqttVersion: \"number\"\n      }); // If no keep alive interval is set, assume 60 seconds.\n\n      if (connectOptions.keepAliveInterval === undefined) connectOptions.keepAliveInterval = 60;\n\n      if (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\n      }\n\n      if (connectOptions.mqttVersion === undefined) {\n        connectOptions.mqttVersionExplicit = false;\n        connectOptions.mqttVersion = 4;\n      } else {\n        connectOptions.mqttVersionExplicit = true;\n      } //Check that if password is set, so is username\n\n\n      if (connectOptions.password === undefined && connectOptions.userName !== undefined) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]));\n\n      if (connectOptions.willMessage) {\n        if (!(connectOptions.willMessage instanceof Message)) throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"])); // The will message must have a payload that can be represented as a string.\n        // Cause the willMessage to throw an exception if this is not the case.\n\n        connectOptions.willMessage.stringPayload;\n        if (typeof connectOptions.willMessage.destinationName === \"undefined\") throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\n      }\n\n      if (typeof connectOptions.cleanSession === \"undefined\") connectOptions.cleanSession = true;\n\n      if (connectOptions.hosts) {\n        if (!(connectOptions.hosts instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        if (connectOptions.hosts.length < 1) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        var usingURIs = false;\n\n        for (var i = 0; i < connectOptions.hosts.length; i++) {\n          if (typeof connectOptions.hosts[i] !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\n\n          if (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\n            if (i == 0) {\n              usingURIs = true;\n            } else if (!usingURIs) {\n              throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\n            }\n          } else if (usingURIs) {\n            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\n          }\n        }\n\n        if (!usingURIs) {\n          if (!connectOptions.ports) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          if (!(connectOptions.ports instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          if (connectOptions.hosts.length != connectOptions.ports.length) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          connectOptions.uris = [];\n\n          for (var i = 0; i < connectOptions.hosts.length; i++) {\n            if (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0) throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectOptions.ports[\" + i + \"]\"]));\n            var host = connectOptions.hosts[i];\n            var port = connectOptions.ports[i];\n            var ipv6 = host.indexOf(\":\") != -1;\n            uri = \"ws://\" + (ipv6 ? \"[\" + host + \"]\" : host) + \":\" + port + path;\n            connectOptions.uris.push(uri);\n          }\n        } else {\n          connectOptions.uris = connectOptions.hosts;\n        }\n      }\n\n      client.connect(connectOptions);\n    };\n    /**\r\n     * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\r\n     *\r\n     * @name Paho.MQTT.Client#subscribe\r\n     * @function\r\n     * @param {string} filter describing the destinations to receive messages from.\r\n     * <br>\r\n     * @param {object} subscribeOptions - used to control the subscription\r\n     *\r\n     * @param {number} subscribeOptions.qos - the maiximum qos of any publications sent\r\n     *                                  as a result of making this subscription.\r\n     * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\r\n     *                                  or onFailure callback.\r\n     * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\r\n     *                                  has been received from the server.\r\n     *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n     *                                  <ol>\r\n     *                                  <li>invocationContext if set in the subscribeOptions.\r\n     *                                  </ol>\r\n     * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\r\n     *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     *                                  <ol>\r\n     *                                  <li>invocationContext - if set in the subscribeOptions.\r\n     *                                  <li>errorCode - a number indicating the nature of the error.\r\n     *                                  <li>errorMessage - text describing the error.\r\n     *                                  </ol>\r\n     * @param {number} subscribeOptions.timeout - which, if present, determines the number of\r\n     *                                  seconds after which the onFailure calback is called.\r\n     *                                  The presence of a timeout does not prevent the onSuccess\r\n     *                                  callback from being called when the subscribe completes.\r\n     * @throws {InvalidState} if the client is not in connected state.\r\n     */\n\n\n    this.subscribe = function (filter, subscribeOptions) {\n      if (typeof filter !== \"string\") throw new Error(\"Invalid argument:\" + filter);\n      subscribeOptions = subscribeOptions || {};\n      validate(subscribeOptions, {\n        qos: \"number\",\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        timeout: \"number\"\n      });\n      if (subscribeOptions.timeout && !subscribeOptions.onFailure) throw new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\n      if (typeof subscribeOptions.qos !== \"undefined\" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2)) throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\n      client.subscribe(filter, subscribeOptions);\n    };\n    /**\r\n     * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\r\n     *\r\n     * @name Paho.MQTT.Client#unsubscribe\r\n     * @function\r\n     * @param {string} filter - describing the destinations to receive messages from.\r\n     * @param {object} unsubscribeOptions - used to control the subscription\r\n     * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\r\n                                          or onFailure callback.\r\n     * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\r\n     *                                    A single response object parameter is passed to the\r\n     *                                    onSuccess callback containing the following fields:\r\n     *                                    <ol>\r\n     *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n     *                                    </ol>\r\n     * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\r\n     *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     *                                    <ol>\r\n     *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n     *                                    <li>errorCode - a number indicating the nature of the error.\r\n     *                                    <li>errorMessage - text describing the error.\r\n     *                                    </ol>\r\n     * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\r\n     *                                    after which the onFailure callback is called. The presence of\r\n     *                                    a timeout does not prevent the onSuccess callback from being\r\n     *                                    called when the unsubscribe completes\r\n     * @throws {InvalidState} if the client is not in connected state.\r\n     */\n\n\n    this.unsubscribe = function (filter, unsubscribeOptions) {\n      if (typeof filter !== \"string\") throw new Error(\"Invalid argument:\" + filter);\n      unsubscribeOptions = unsubscribeOptions || {};\n      validate(unsubscribeOptions, {\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        timeout: \"number\"\n      });\n      if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure) throw new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\n      client.unsubscribe(filter, unsubscribeOptions);\n    };\n    /**\r\n     * Send a message to the consumers of the destination in the Message.\r\n     *\r\n     * @name Paho.MQTT.Client#send\r\n     * @function\r\n     * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\r\n     * \t\t\t\t\t   - If it is the only parameter, used as Paho.MQTT.Message object.\r\n     * @param {String|ArrayBuffer} payload - The message data to be sent.\r\n     * @param {number} qos The Quality of Service used to deliver the message.\r\n     * \t\t<dl>\r\n     * \t\t\t<dt>0 Best effort (default).\r\n     *     \t\t\t<dt>1 At least once.\r\n     *     \t\t\t<dt>2 Exactly once.\r\n     * \t\t</dl>\r\n     * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n     *                     to both current and future subscriptions.\r\n     *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n     *                     A received message has the retained boolean set to true if the message was published\r\n     *                     with the retained boolean set to true\r\n     *                     and the subscrption was made after the message has been published.\r\n     * @throws {InvalidState} if the client is not connected.\r\n     */\n\n\n    this.send = function (topic, payload, qos, retained) {\n      var message;\n\n      if (arguments.length == 0) {\n        throw new Error(\"Invalid argument.\" + \"length\");\n      } else if (arguments.length == 1) {\n        if (!(topic instanceof Message) && typeof topic !== \"string\") throw new Error(\"Invalid argument:\" + typeof topic);\n        message = topic;\n        if (typeof message.destinationName === \"undefined\") throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, \"Message.destinationName\"]));\n        client.send(message);\n      } else {\n        //parameter checking in Message object\n        message = new Message(payload);\n        message.destinationName = topic;\n        if (arguments.length >= 3) message.qos = qos;\n        if (arguments.length >= 4) message.retained = retained;\n        client.send(message);\n      }\n    };\n    /**\r\n     * Normal disconnect of this Messaging client from its server.\r\n     *\r\n     * @name Paho.MQTT.Client#disconnect\r\n     * @function\r\n     * @throws {InvalidState} if the client is already disconnected.\r\n     */\n\n\n    this.disconnect = function () {\n      client.disconnect();\n    };\n    /**\r\n     * Get the contents of the trace log.\r\n     *\r\n     * @name Paho.MQTT.Client#getTraceLog\r\n     * @function\r\n     * @return {Object[]} tracebuffer containing the time ordered trace records.\r\n     */\n\n\n    this.getTraceLog = function () {\n      return client.getTraceLog();\n    };\n    /**\r\n     * Start tracing.\r\n     *\r\n     * @name Paho.MQTT.Client#startTrace\r\n     * @function\r\n     */\n\n\n    this.startTrace = function () {\n      client.startTrace();\n    };\n    /**\r\n     * Stop tracing.\r\n     *\r\n     * @name Paho.MQTT.Client#stopTrace\r\n     * @function\r\n     */\n\n\n    this.stopTrace = function () {\n      client.stopTrace();\n    };\n\n    this.isConnected = function () {\n      return client.connected;\n    };\n  };\n\n  Client.prototype = {\n    get host() {\n      return this._getHost();\n    },\n\n    set host(newHost) {\n      this._setHost(newHost);\n    },\n\n    get port() {\n      return this._getPort();\n    },\n\n    set port(newPort) {\n      this._setPort(newPort);\n    },\n\n    get path() {\n      return this._getPath();\n    },\n\n    set path(newPath) {\n      this._setPath(newPath);\n    },\n\n    get clientId() {\n      return this._getClientId();\n    },\n\n    set clientId(newClientId) {\n      this._setClientId(newClientId);\n    },\n\n    get onConnectionLost() {\n      return this._getOnConnectionLost();\n    },\n\n    set onConnectionLost(newOnConnectionLost) {\n      this._setOnConnectionLost(newOnConnectionLost);\n    },\n\n    get onMessageDelivered() {\n      return this._getOnMessageDelivered();\n    },\n\n    set onMessageDelivered(newOnMessageDelivered) {\n      this._setOnMessageDelivered(newOnMessageDelivered);\n    },\n\n    get onMessageArrived() {\n      return this._getOnMessageArrived();\n    },\n\n    set onMessageArrived(newOnMessageArrived) {\n      this._setOnMessageArrived(newOnMessageArrived);\n    },\n\n    get trace() {\n      return this._getTrace();\n    },\n\n    set trace(newTraceFunction) {\n      this._setTrace(newTraceFunction);\n    }\n\n  };\n  /**\r\n   * An application message, sent or received.\r\n   * <p>\r\n   * All attributes may be null, which implies the default values.\r\n   *\r\n   * @name Paho.MQTT.Message\r\n   * @constructor\r\n   * @param {String|ArrayBuffer} payload The message data to be sent.\r\n   * <p>\r\n   * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\r\n   * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\r\n   * <p>\r\n   * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\r\n   *                    (for messages about to be sent) or the name of the destination from which the message has been received.\r\n   *                    (for messages received by the onMessage function).\r\n   * <p>\r\n   * @property {number} qos The Quality of Service used to deliver the message.\r\n   * <dl>\r\n   *     <dt>0 Best effort (default).\r\n   *     <dt>1 At least once.\r\n   *     <dt>2 Exactly once.\r\n   * </dl>\r\n   * <p>\r\n   * @property {Boolean} retained If true, the message is to be retained by the server and delivered\r\n   *                     to both current and future subscriptions.\r\n   *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n   *                     A received message has the retained boolean set to true if the message was published\r\n   *                     with the retained boolean set to true\r\n   *                     and the subscrption was made after the message has been published.\r\n   * <p>\r\n   * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\r\n   *                     This is only set on messages received from the server.\r\n   *\r\n   */\n\n  var Message = function (newPayload) {\n    var payload;\n\n    if (typeof newPayload === \"string\" || newPayload instanceof ArrayBuffer || newPayload instanceof Int8Array || newPayload instanceof Uint8Array || newPayload instanceof Int16Array || newPayload instanceof Uint16Array || newPayload instanceof Int32Array || newPayload instanceof Uint32Array || newPayload instanceof Float32Array || newPayload instanceof Float64Array) {\n      payload = newPayload;\n    } else {\n      throw format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]);\n    }\n\n    this._getPayloadString = function () {\n      if (typeof payload === \"string\") return payload;else return parseUTF8(payload, 0, payload.length);\n    };\n\n    this._getPayloadBytes = function () {\n      if (typeof payload === \"string\") {\n        var buffer = new ArrayBuffer(UTF8Length(payload));\n        var byteStream = new Uint8Array(buffer);\n        stringToUTF8(payload, byteStream, 0);\n        return byteStream;\n      } else {\n        return payload;\n      }\n\n      ;\n    };\n\n    var destinationName = undefined;\n\n    this._getDestinationName = function () {\n      return destinationName;\n    };\n\n    this._setDestinationName = function (newDestinationName) {\n      if (typeof newDestinationName === \"string\") destinationName = newDestinationName;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\n    };\n\n    var qos = 0;\n\n    this._getQos = function () {\n      return qos;\n    };\n\n    this._setQos = function (newQos) {\n      if (newQos === 0 || newQos === 1 || newQos === 2) qos = newQos;else throw new Error(\"Invalid argument:\" + newQos);\n    };\n\n    var retained = false;\n\n    this._getRetained = function () {\n      return retained;\n    };\n\n    this._setRetained = function (newRetained) {\n      if (typeof newRetained === \"boolean\") retained = newRetained;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\n    };\n\n    var duplicate = false;\n\n    this._getDuplicate = function () {\n      return duplicate;\n    };\n\n    this._setDuplicate = function (newDuplicate) {\n      duplicate = newDuplicate;\n    };\n  };\n\n  Message.prototype = {\n    get payloadString() {\n      return this._getPayloadString();\n    },\n\n    get payloadBytes() {\n      return this._getPayloadBytes();\n    },\n\n    get destinationName() {\n      return this._getDestinationName();\n    },\n\n    set destinationName(newDestinationName) {\n      this._setDestinationName(newDestinationName);\n    },\n\n    get qos() {\n      return this._getQos();\n    },\n\n    set qos(newQos) {\n      this._setQos(newQos);\n    },\n\n    get retained() {\n      return this._getRetained();\n    },\n\n    set retained(newRetained) {\n      this._setRetained(newRetained);\n    },\n\n    get duplicate() {\n      return this._getDuplicate();\n    },\n\n    set duplicate(newDuplicate) {\n      this._setDuplicate(newDuplicate);\n    }\n\n  }; // Module contents.\n\n  return {\n    Client: Client,\n    Message: Message\n  };\n}(window);","map":{"version":3,"sources":["C:/Users/chrib/Dropbox/Studium/5. Bristol/8.Software_Eng/Github/now-ui-kit-react-master/src/views/examples/paho.js"],"names":["Paho","MQTT","global","version","buildLevel","MESSAGE_TYPE","CONNECT","CONNACK","PUBLISH","PUBACK","PUBREC","PUBREL","PUBCOMP","SUBSCRIBE","SUBACK","UNSUBSCRIBE","UNSUBACK","PINGREQ","PINGRESP","DISCONNECT","validate","obj","keys","key","hasOwnProperty","Error","format","ERROR","INVALID_TYPE","errorStr","scope","f","apply","arguments","OK","code","text","CONNECT_TIMEOUT","SUBSCRIBE_TIMEOUT","UNSUBSCRIBE_TIMEOUT","PING_TIMEOUT","INTERNAL_ERROR","CONNACK_RETURNCODE","SOCKET_ERROR","SOCKET_CLOSE","MALFORMED_UTF","UNSUPPORTED","INVALID_STATE","INVALID_ARGUMENT","UNSUPPORTED_OPERATION","INVALID_STORED_DATA","INVALID_MQTT_MESSAGE_TYPE","MALFORMED_UNICODE","CONNACK_RC","error","substitutions","field","start","i","length","indexOf","part1","substring","part2","MqttProtoIdentifierv3","MqttProtoIdentifierv4","WireMessage","type","options","name","prototype","encode","first","remLength","topicStrLength","Array","destinationNameLength","messageIdentifier","undefined","mqttVersion","UTF8Length","clientId","willMessage","destinationName","willMessagePayloadBytes","payloadBytes","Uint8Array","byteLength","userName","password","topics","requestedQos","payloadMessage","duplicate","qos","retained","ArrayBuffer","buffer","mbi","encodeMBI","pos","byteStream","set","writeString","connectFlags","cleanSession","writeUint16","keepAliveInterval","decodeMessage","input","startingPos","messageInfo","digit","multiplier","endPos","wireMessage","connectAcknowledgeFlags","sessionPresent","returnCode","len","readUint16","topicName","parseUTF8","message","Message","subarray","offset","utf8Length","stringToUTF8","number","output","numBytes","charCode","charCodeAt","lowCharCode","isNaN","utf16","byte1","byte2","toString","byte3","byte4","String","fromCharCode","Pinger","client","window","_client","_window","_keepAliveInterval","isReset","pingReq","doTimeout","pinger","doPing","_trace","_disconnected","socket","send","timeout","setTimeout","reset","clearTimeout","cancel","Timeout","timeoutSeconds","action","args","ClientImpl","uri","host","port","path","_localKey","_msg_queue","_sentMessages","_receivedMessages","_notify_msg_sent","_message_identifier","_sequence","localStorage","restore","connected","maxMessageIdentifier","connectOptions","hostIndex","onConnectionLost","onMessageDelivered","onMessageArrived","traceFunction","_connectTimeout","sendPinger","receivePinger","receiveBuffer","_traceBuffer","_MAX_TRACE_ENTRIES","connect","connectOptionsMasked","_traceMask","uris","_doConnect","subscribe","filter","subscribeOptions","onSuccess","grantedQos","invocationContext","onFailure","errorCode","timeOut","errorMessage","_requires_ack","_schedule_message","unsubscribe","unsubscribeOptions","callback","disconnect","getTraceLog","Date","startTrace","stopTrace","wsurl","useSSL","uriParts","split","join","WebSocket","binaryType","onopen","_on_socket_open","onmessage","_on_socket_message","onerror","_on_socket_error","onclose","_on_socket_close","push","_process_queue","store","prefix","storedMessage","pubRecReceived","hex","messageBytes","payloadHex","sequence","setItem","JSON","stringify","value","getItem","parse","x","parseInt","fifo","reverse","pop","_socket_send","messageCount","Object","event","data","messages","_deframeMessages","_handleMessage","byteArray","newData","result","stack","sentMessage","removeItem","receivedMessage","sequencedMessages","msgId","sort","a","b","pubRelMessage","_receivePublish","_receiveMessage","pubCompMessage","wireMessageMasked","pubAckMessage","pubRecMessage","wireMmessage","errorText","readyState","close","mqttVersionExplicit","record","slice","call","severity","max","shift","traceObject","masked","traceObjectMasked","attr","Client","match","ipv6AddSBracket","clientIdLength","_getHost","_setHost","_getPort","_setPort","_getPath","_setPath","_getURI","_setURI","_getClientId","_setClientId","_getOnConnectionLost","_setOnConnectionLost","newOnConnectionLost","_getOnMessageDelivered","_setOnMessageDelivered","newOnMessageDelivered","_getOnMessageArrived","_setOnMessageArrived","newOnMessageArrived","_getTrace","_setTrace","trace","hosts","ports","stringPayload","usingURIs","test","ipv6","topic","payload","isConnected","newHost","newPort","newPath","newClientId","newTraceFunction","newPayload","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_getPayloadString","_getPayloadBytes","_getDestinationName","_setDestinationName","newDestinationName","_getQos","_setQos","newQos","_getRetained","_setRetained","newRetained","_getDuplicate","_setDuplicate","newDuplicate","payloadString"],"mappings":"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","sourcesContent":["/*******************************************************************************\r\n * Copyright (c) 2013 IBM Corp.\r\n *\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * and Eclipse Distribution License v1.0 which accompany this distribution.\r\n *\r\n * The Eclipse Public License is available at\r\n *    http://www.eclipse.org/legal/epl-v10.html\r\n * and the Eclipse Distribution License is available at\r\n *   http://www.eclipse.org/org/documents/edl-v10.php.\r\n *\r\n * Contributors:\r\n *    Andrew Banks - initial API and implementation and initial documentation\r\n *******************************************************************************/\r\n\r\n\r\n// Only expose a single object name in the global namespace.\r\n// Everything must go through this module. Global Paho.MQTT module\r\n// only has a single public function, client, which returns\r\n// a Paho.MQTT client object given connection details.\r\n\r\n/**\r\n * Send and receive messages using web browsers.\r\n * <p>\r\n * This programming interface lets a JavaScript client application use the MQTT V3.1 or\r\n * V3.1.1 protocol to connect to an MQTT-supporting messaging server.\r\n *\r\n * The function supported includes:\r\n * <ol>\r\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number.\r\n * <li>Specifying options that relate to the communications link with the server,\r\n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\r\n * <li>Subscribing to and receiving messages from MQTT Topics.\r\n * <li>Publishing messages to MQTT Topics.\r\n * </ol>\r\n * <p>\r\n * The API consists of two main objects:\r\n * <dl>\r\n * <dt><b>{@link Paho.MQTT.Client}</b></dt>\r\n * <dd>This contains methods that provide the functionality of the API,\r\n * including provision of callbacks that notify the application when a message\r\n * arrives from or is delivered to the messaging server,\r\n * or when the status of its connection to the messaging server changes.</dd>\r\n * <dt><b>{@link Paho.MQTT.Message}</b></dt>\r\n * <dd>This encapsulates the payload of the message along with various attributes\r\n * associated with its delivery, in particular the destination to which it has\r\n * been (or is about to be) sent.</dd>\r\n * </dl>\r\n * <p>\r\n * The programming interface validates parameters passed to it, and will throw\r\n * an Error containing an error message intended for developer use, if it detects\r\n * an error with any parameter.\r\n * <p>\r\n * Example:\r\n *\r\n * <code><pre>\r\nclient = new Paho.MQTT.Client(location.hostname, Number(location.port), \"clientId\");\r\nclient.onConnectionLost = onConnectionLost;\r\nclient.onMessageArrived = onMessageArrived;\r\nclient.connect({onSuccess:onConnect});\r\n\r\nfunction onConnect() {\r\n  // Once a connection has been made, make a subscription and send a message.\r\n  console.log(\"onConnect\");\r\n  client.subscribe(\"/World\");\r\n  message = new Paho.MQTT.Message(\"Hello\");\r\n  message.destinationName = \"/World\";\r\n  client.send(message);\r\n};\r\nfunction onConnectionLost(responseObject) {\r\n  if (responseObject.errorCode !== 0)\r\n\tconsole.log(\"onConnectionLost:\"+responseObject.errorMessage);\r\n};\r\nfunction onMessageArrived(message) {\r\n  console.log(\"onMessageArrived:\"+message.payloadString);\r\n  client.disconnect();\r\n};\r\n * </pre></code>\r\n * @namespace Paho.MQTT\r\n */\r\n\r\nif (typeof Paho === \"undefined\") {\r\n\tPaho = {};\r\n}\r\n\r\nPaho.MQTT = (function (global) {\r\n\r\n\t// Private variables below, these are only visible inside the function closure\r\n\t// which is used to define the module.\r\n\r\n\tvar version = \"@VERSION@\";\r\n\tvar buildLevel = \"@BUILDLEVEL@\";\r\n\r\n\t/**\r\n\t * Unique message type identifiers, with associated\r\n\t * associated integer values.\r\n\t * @private\r\n\t */\r\n\tvar MESSAGE_TYPE = {\r\n\t\tCONNECT: 1,\r\n\t\tCONNACK: 2,\r\n\t\tPUBLISH: 3,\r\n\t\tPUBACK: 4,\r\n\t\tPUBREC: 5,\r\n\t\tPUBREL: 6,\r\n\t\tPUBCOMP: 7,\r\n\t\tSUBSCRIBE: 8,\r\n\t\tSUBACK: 9,\r\n\t\tUNSUBSCRIBE: 10,\r\n\t\tUNSUBACK: 11,\r\n\t\tPINGREQ: 12,\r\n\t\tPINGRESP: 13,\r\n\t\tDISCONNECT: 14\r\n\t};\r\n\r\n\t// Collection of utility methods used to simplify module code\r\n\t// and promote the DRY pattern.\r\n\r\n\t/**\r\n\t * Validate an object's parameter names to ensure they\r\n\t * match a list of expected variables name for this option\r\n\t * type. Used to ensure option object passed into the API don't\r\n\t * contain erroneous parameters.\r\n\t * @param {Object} obj - User options object\r\n\t * @param {Object} keys - valid keys and types that may exist in obj.\r\n\t * @throws {Error} Invalid option parameter found.\r\n\t * @private\r\n\t */\r\n\tvar validate = function(obj, keys) {\r\n\t\tfor (var key in obj) {\r\n\t\t\tif (obj.hasOwnProperty(key)) {\r\n\t\t\t\tif (keys.hasOwnProperty(key)) {\r\n\t\t\t\t\tif (typeof obj[key] !== keys[key])\r\n\t\t\t\t\t   throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\r\n\t\t\t\t\tfor (var key in keys)\r\n\t\t\t\t\t\tif (keys.hasOwnProperty(key))\r\n\t\t\t\t\t\t\terrorStr = errorStr+\" \"+key;\r\n\t\t\t\t\tthrow new Error(errorStr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Return a new function which runs the user function bound\r\n\t * to a fixed scope.\r\n\t * @param {function} User function\r\n\t * @param {object} Function scope\r\n\t * @return {function} User function bound to another scope\r\n\t * @private\r\n\t */\r\n\tvar scope = function (f, scope) {\r\n\t\treturn function () {\r\n\t\t\treturn f.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * Unique message type identifiers, with associated\r\n\t * associated integer values.\r\n\t * @private\r\n\t */\r\n\tvar ERROR = {\r\n\t\tOK: {code:0, text:\"AMQJSC0000I OK.\"},\r\n\t\tCONNECT_TIMEOUT: {code:1, text:\"AMQJSC0001E Connect timed out.\"},\r\n\t\tSUBSCRIBE_TIMEOUT: {code:2, text:\"AMQJS0002E Subscribe timed out.\"},\r\n\t\tUNSUBSCRIBE_TIMEOUT: {code:3, text:\"AMQJS0003E Unsubscribe timed out.\"},\r\n\t\tPING_TIMEOUT: {code:4, text:\"AMQJS0004E Ping timed out.\"},\r\n\t\tINTERNAL_ERROR: {code:5, text:\"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\"},\r\n\t\tCONNACK_RETURNCODE: {code:6, text:\"AMQJS0006E Bad Connack return code:{0} {1}.\"},\r\n\t\tSOCKET_ERROR: {code:7, text:\"AMQJS0007E Socket error:{0}.\"},\r\n\t\tSOCKET_CLOSE: {code:8, text:\"AMQJS0008I Socket closed.\"},\r\n\t\tMALFORMED_UTF: {code:9, text:\"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"},\r\n\t\tUNSUPPORTED: {code:10, text:\"AMQJS0010E {0} is not supported by this browser.\"},\r\n\t\tINVALID_STATE: {code:11, text:\"AMQJS0011E Invalid state {0}.\"},\r\n\t\tINVALID_TYPE: {code:12, text:\"AMQJS0012E Invalid type {0} for {1}.\"},\r\n\t\tINVALID_ARGUMENT: {code:13, text:\"AMQJS0013E Invalid argument {0} for {1}.\"},\r\n\t\tUNSUPPORTED_OPERATION: {code:14, text:\"AMQJS0014E Unsupported operation.\"},\r\n\t\tINVALID_STORED_DATA: {code:15, text:\"AMQJS0015E Invalid data in local storage key={0} value={1}.\"},\r\n\t\tINVALID_MQTT_MESSAGE_TYPE: {code:16, text:\"AMQJS0016E Invalid MQTT message type {0}.\"},\r\n\t\tMALFORMED_UNICODE: {code:17, text:\"AMQJS0017E Malformed Unicode string:{0} {1}.\"},\r\n\t};\r\n\r\n\t/** CONNACK RC Meaning. */\r\n\tvar CONNACK_RC = {\r\n\t\t0:\"Connection Accepted\",\r\n\t\t1:\"Connection Refused: unacceptable protocol version\",\r\n\t\t2:\"Connection Refused: identifier rejected\",\r\n\t\t3:\"Connection Refused: server unavailable\",\r\n\t\t4:\"Connection Refused: bad user name or password\",\r\n\t\t5:\"Connection Refused: not authorized\"\r\n\t};\r\n\r\n\t/**\r\n\t * Format an error message text.\r\n\t * @private\r\n\t * @param {error} ERROR.KEY value above.\r\n\t * @param {substitutions} [array] substituted into the text.\r\n\t * @return the text with the substitutions made.\r\n\t */\r\n\tvar format = function(error, substitutions) {\r\n\t\tvar text = error.text;\r\n\t\tif (substitutions) {\r\n\t\t  var field,start;\r\n\t\t  for (var i=0; i<substitutions.length; i++) {\r\n\t\t\tfield = \"{\"+i+\"}\";\r\n\t\t\tstart = text.indexOf(field);\r\n\t\t\tif(start > 0) {\r\n\t\t\t\tvar part1 = text.substring(0,start);\r\n\t\t\t\tvar part2 = text.substring(start+field.length);\r\n\t\t\t\ttext = part1+substitutions[i]+part2;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\treturn text;\r\n\t};\r\n\r\n\t//MQTT protocol and version          6    M    Q    I    s    d    p    3\r\n\tvar MqttProtoIdentifierv3 = [0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70,0x03];\r\n\t//MQTT proto/version for 311         4    M    Q    T    T    4\r\n\tvar MqttProtoIdentifierv4 = [0x00,0x04,0x4d,0x51,0x54,0x54,0x04];\r\n\r\n\t/**\r\n\t * Construct an MQTT wire protocol message.\r\n\t * @param type MQTT packet type.\r\n\t * @param options optional wire message attributes.\r\n\t *\r\n\t * Optional properties\r\n\t *\r\n\t * messageIdentifier: message ID in the range [0..65535]\r\n\t * payloadMessage:\tApplication Message - PUBLISH only\r\n\t * connectStrings:\tarray of 0 or more Strings to be put into the CONNECT payload\r\n\t * topics:\t\t\tarray of strings (SUBSCRIBE, UNSUBSCRIBE)\r\n\t * requestQoS:\t\tarray of QoS values [0..2]\r\n\t *\r\n\t * \"Flag\" properties\r\n\t * cleanSession:\ttrue if present / false if absent (CONNECT)\r\n\t * willMessage:  \ttrue if present / false if absent (CONNECT)\r\n\t * isRetained:\t\ttrue if present / false if absent (CONNECT)\r\n\t * userName:\t\ttrue if present / false if absent (CONNECT)\r\n\t * password:\t\ttrue if present / false if absent (CONNECT)\r\n\t * keepAliveInterval:\tinteger [0..65535]  (CONNECT)\r\n\t *\r\n\t * @private\r\n\t * @ignore\r\n\t */\r\n\tvar WireMessage = function (type, options) {\r\n\t\tthis.type = type;\r\n\t\tfor (var name in options) {\r\n\t\t\tif (options.hasOwnProperty(name)) {\r\n\t\t\t\tthis[name] = options[name];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tWireMessage.prototype.encode = function() {\r\n\t\t// Compute the first byte of the fixed header\r\n\t\tvar first = ((this.type & 0x0f) << 4);\r\n\r\n\t\t/*\r\n\t\t * Now calculate the length of the variable header + payload by adding up the lengths\r\n\t\t * of all the component parts\r\n\t\t */\r\n\r\n\t\tvar remLength = 0;\r\n\t\tvar topicStrLength = new Array();\r\n\t\tvar destinationNameLength = 0;\r\n\r\n\t\t// if the message contains a messageIdentifier then we need two bytes for that\r\n\t\tif (this.messageIdentifier != undefined)\r\n\t\t\tremLength += 2;\r\n\r\n\t\tswitch(this.type) {\r\n\t\t\t// If this a Connect then we need to include 12 bytes for its header\r\n\t\t\tcase MESSAGE_TYPE.CONNECT:\r\n\t\t\t\tswitch(this.mqttVersion) {\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tremLength += MqttProtoIdentifierv3.length + 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tremLength += MqttProtoIdentifierv4.length + 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tremLength += UTF8Length(this.clientId) + 2;\r\n\t\t\t\tif (this.willMessage != undefined) {\r\n\t\t\t\t\tremLength += UTF8Length(this.willMessage.destinationName) + 2;\r\n\t\t\t\t\t// Will message is always a string, sent as UTF-8 characters with a preceding length.\r\n\t\t\t\t\tvar willMessagePayloadBytes = this.willMessage.payloadBytes;\r\n\t\t\t\t\tif (!(willMessagePayloadBytes instanceof Uint8Array))\r\n\t\t\t\t\t\twillMessagePayloadBytes = new Uint8Array(payloadBytes);\r\n\t\t\t\t\tremLength += willMessagePayloadBytes.byteLength +2;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.userName != undefined)\r\n\t\t\t\t\tremLength += UTF8Length(this.userName) + 2;\r\n\t\t\t\tif (this.password != undefined)\r\n\t\t\t\t\tremLength += UTF8Length(this.password) + 2;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// Subscribe, Unsubscribe can both contain topic strings\r\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\r\n\t\t\t\tfirst |= 0x02; // Qos = 1;\r\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\r\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\r\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\r\n\t\t\t\t}\r\n\t\t\t\tremLength += this.requestedQos.length; // 1 byte for each topic's Qos\r\n\t\t\t\t// QoS on Subscribe only\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\r\n\t\t\t\tfirst |= 0x02; // Qos = 1;\r\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\r\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\r\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBREL:\r\n\t\t\t\tfirst |= 0x02; // Qos = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\r\n\t\t\t\tif (this.payloadMessage.duplicate) first |= 0x08;\r\n\t\t\t\tfirst  = first |= (this.payloadMessage.qos << 1);\r\n\t\t\t\tif (this.payloadMessage.retained) first |= 0x01;\r\n\t\t\t\tdestinationNameLength = UTF8Length(this.payloadMessage.destinationName);\r\n\t\t\t\tremLength += destinationNameLength + 2;\r\n\t\t\t\tvar payloadBytes = this.payloadMessage.payloadBytes;\r\n\t\t\t\tremLength += payloadBytes.byteLength;\r\n\t\t\t\tif (payloadBytes instanceof ArrayBuffer)\r\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes);\r\n\t\t\t\telse if (!(payloadBytes instanceof Uint8Array))\r\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes.buffer);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.DISCONNECT:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t;\r\n\t\t}\r\n\r\n\t\t// Now we can allocate a buffer for the message\r\n\r\n\t\tvar mbi = encodeMBI(remLength);  // Convert the length to MQTT MBI format\r\n\t\tvar pos = mbi.length + 1;        // Offset of start of variable header\r\n\t\tvar buffer = new ArrayBuffer(remLength + pos);\r\n\t\tvar byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\r\n\r\n\t\t//Write the fixed header into the buffer\r\n\t\tbyteStream[0] = first;\r\n\t\tbyteStream.set(mbi,1);\r\n\r\n\t\t// If this is a PUBLISH then the variable header starts with a topic\r\n\t\tif (this.type == MESSAGE_TYPE.PUBLISH)\r\n\t\t\tpos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\r\n\t\t// If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\r\n\r\n\t\telse if (this.type == MESSAGE_TYPE.CONNECT) {\r\n\t\t\tswitch (this.mqttVersion) {\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv3, pos);\r\n\t\t\t\t\tpos += MqttProtoIdentifierv3.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv4, pos);\r\n\t\t\t\t\tpos += MqttProtoIdentifierv4.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tvar connectFlags = 0;\r\n\t\t\tif (this.cleanSession)\r\n\t\t\t\tconnectFlags = 0x02;\r\n\t\t\tif (this.willMessage != undefined ) {\r\n\t\t\t\tconnectFlags |= 0x04;\r\n\t\t\t\tconnectFlags |= (this.willMessage.qos<<3);\r\n\t\t\t\tif (this.willMessage.retained) {\r\n\t\t\t\t\tconnectFlags |= 0x20;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.userName != undefined)\r\n\t\t\t\tconnectFlags |= 0x80;\r\n\t\t\tif (this.password != undefined)\r\n\t\t\t\tconnectFlags |= 0x40;\r\n\t\t\tbyteStream[pos++] = connectFlags;\r\n\t\t\tpos = writeUint16 (this.keepAliveInterval, byteStream, pos);\r\n\t\t}\r\n\r\n\t\t// Output the messageIdentifier - if there is one\r\n\t\tif (this.messageIdentifier != undefined)\r\n\t\t\tpos = writeUint16 (this.messageIdentifier, byteStream, pos);\r\n\r\n\t\tswitch(this.type) {\r\n\t\t\tcase MESSAGE_TYPE.CONNECT:\r\n\t\t\t\tpos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\r\n\t\t\t\tif (this.willMessage != undefined) {\r\n\t\t\t\t\tpos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\r\n\t\t\t\t\tpos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\r\n\t\t\t\t\tbyteStream.set(willMessagePayloadBytes, pos);\r\n\t\t\t\t\tpos += willMessagePayloadBytes.byteLength;\r\n\r\n\t\t\t\t}\r\n\t\t\tif (this.userName != undefined)\r\n\t\t\t\tpos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\r\n\t\t\tif (this.password != undefined)\r\n\t\t\t\tpos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\r\n\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\r\n\t\t\t\t// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\r\n\t\t\t\tbyteStream.set(payloadBytes, pos);\r\n\r\n\t\t\t\tbreak;\r\n\r\n//    \t    case MESSAGE_TYPE.PUBREC:\r\n//    \t    case MESSAGE_TYPE.PUBREL:\r\n//    \t    case MESSAGE_TYPE.PUBCOMP:\r\n//    \t    \tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\r\n\t\t\t\t// SUBSCRIBE has a list of topic strings and request QoS\r\n\t\t\t\tfor (var i=0; i<this.topics.length; i++) {\r\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\r\n\t\t\t\t\tbyteStream[pos++] = this.requestedQos[i];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\r\n\t\t\t\t// UNSUBSCRIBE has a list of topic strings\r\n\t\t\t\tfor (var i=0; i<this.topics.length; i++)\r\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// Do nothing.\r\n\t\t}\r\n\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tfunction decodeMessage(input,pos) {\r\n\t    var startingPos = pos;\r\n\t\tvar first = input[pos];\r\n\t\tvar type = first >> 4;\r\n\t\tvar messageInfo = first &= 0x0f;\r\n\t\tpos += 1;\r\n\r\n\r\n\t\t// Decode the remaining length (MBI format)\r\n\r\n\t\tvar digit;\r\n\t\tvar remLength = 0;\r\n\t\tvar multiplier = 1;\r\n\t\tdo {\r\n\t\t\tif (pos == input.length) {\r\n\t\t\t    return [null,startingPos];\r\n\t\t\t}\r\n\t\t\tdigit = input[pos++];\r\n\t\t\tremLength += ((digit & 0x7F) * multiplier);\r\n\t\t\tmultiplier *= 128;\r\n\t\t} while ((digit & 0x80) != 0);\r\n\r\n\t\tvar endPos = pos+remLength;\r\n\t\tif (endPos > input.length) {\r\n\t\t    return [null,startingPos];\r\n\t\t}\r\n\r\n\t\tvar wireMessage = new WireMessage(type);\r\n\t\tswitch(type) {\r\n\t\t\tcase MESSAGE_TYPE.CONNACK:\r\n\t\t\t\tvar connectAcknowledgeFlags = input[pos++];\r\n\t\t\t\tif (connectAcknowledgeFlags & 0x01)\r\n\t\t\t\t\twireMessage.sessionPresent = true;\r\n\t\t\t\twireMessage.returnCode = input[pos++];\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\r\n\t\t\t\tvar qos = (messageInfo >> 1) & 0x03;\r\n\r\n\t\t\t\tvar len = readUint16(input, pos);\r\n\t\t\t\tpos += 2;\r\n\t\t\t\tvar topicName = parseUTF8(input, pos, len);\r\n\t\t\t\tpos += len;\r\n\t\t\t\t// If QoS 1 or 2 there will be a messageIdentifier\r\n\t\t\t\tif (qos > 0) {\r\n\t\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\r\n\t\t\t\t\tpos += 2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar message = new Paho.MQTT.Message(input.subarray(pos, endPos));\r\n\t\t\t\tif ((messageInfo & 0x01) == 0x01)\r\n\t\t\t\t\tmessage.retained = true;\r\n\t\t\t\tif ((messageInfo & 0x08) == 0x08)\r\n\t\t\t\t\tmessage.duplicate =  true;\r\n\t\t\t\tmessage.qos = qos;\r\n\t\t\t\tmessage.destinationName = topicName;\r\n\t\t\t\twireMessage.payloadMessage = message;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase  MESSAGE_TYPE.PUBACK:\r\n\t\t\tcase  MESSAGE_TYPE.PUBREC:\r\n\t\t\tcase  MESSAGE_TYPE.PUBREL:\r\n\t\t\tcase  MESSAGE_TYPE.PUBCOMP:\r\n\t\t\tcase  MESSAGE_TYPE.UNSUBACK:\r\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase  MESSAGE_TYPE.SUBACK:\r\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\r\n\t\t\t\tpos += 2;\r\n\t\t\t\twireMessage.returnCode = input.subarray(pos, endPos);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t;\r\n\t\t}\r\n\r\n\t\treturn [wireMessage,endPos];\r\n\t}\r\n\r\n\tfunction writeUint16(input, buffer, offset) {\r\n\t\tbuffer[offset++] = input >> 8;      //MSB\r\n\t\tbuffer[offset++] = input % 256;     //LSB\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tfunction writeString(input, utf8Length, buffer, offset) {\r\n\t\toffset = writeUint16(utf8Length, buffer, offset);\r\n\t\tstringToUTF8(input, buffer, offset);\r\n\t\treturn offset + utf8Length;\r\n\t}\r\n\r\n\tfunction readUint16(buffer, offset) {\r\n\t\treturn 256*buffer[offset] + buffer[offset+1];\r\n\t}\r\n\r\n\t/**\r\n\t * Encodes an MQTT Multi-Byte Integer\r\n\t * @private\r\n\t */\r\n\tfunction encodeMBI(number) {\r\n\t\tvar output = new Array(1);\r\n\t\tvar numBytes = 0;\r\n\r\n\t\tdo {\r\n\t\t\tvar digit = number % 128;\r\n\t\t\tnumber = number >> 7;\r\n\t\t\tif (number > 0) {\r\n\t\t\t\tdigit |= 0x80;\r\n\t\t\t}\r\n\t\t\toutput[numBytes++] = digit;\r\n\t\t} while ( (number > 0) && (numBytes<4) );\r\n\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a String and calculates its length in bytes when encoded in UTF8.\r\n\t * @private\r\n\t */\r\n\tfunction UTF8Length(input) {\r\n\t\tvar output = 0;\r\n\t\tfor (var i = 0; i<input.length; i++)\r\n\t\t{\r\n\t\t\tvar charCode = input.charCodeAt(i);\r\n\t\t\t\tif (charCode > 0x7FF)\r\n\t\t\t\t   {\r\n\t\t\t\t\t  // Surrogate pair means its a 4 byte character\r\n\t\t\t\t\t  if (0xD800 <= charCode && charCode <= 0xDBFF)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t  i++;\r\n\t\t\t\t\t\t  output++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t   output +=3;\r\n\t\t\t\t   }\r\n\t\t\telse if (charCode > 0x7F)\r\n\t\t\t\toutput +=2;\r\n\t\t\telse\r\n\t\t\t\toutput++;\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a String and writes it into an array as UTF8 encoded bytes.\r\n\t * @private\r\n\t */\r\n\tfunction stringToUTF8(input, output, start) {\r\n\t\tvar pos = start;\r\n\t\tfor (var i = 0; i<input.length; i++) {\r\n\t\t\tvar charCode = input.charCodeAt(i);\r\n\r\n\t\t\t// Check for a surrogate pair.\r\n\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF) {\r\n\t\t\t\tvar lowCharCode = input.charCodeAt(++i);\r\n\t\t\t\tif (isNaN(lowCharCode)) {\r\n\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\r\n\t\t\t\t}\r\n\t\t\t\tcharCode = ((charCode - 0xD800)<<10) + (lowCharCode - 0xDC00) + 0x10000;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (charCode <= 0x7F) {\r\n\t\t\t\toutput[pos++] = charCode;\r\n\t\t\t} else if (charCode <= 0x7FF) {\r\n\t\t\t\toutput[pos++] = charCode>>6  & 0x1F | 0xC0;\r\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\r\n\t\t\t} else if (charCode <= 0xFFFF) {\r\n\t\t\t\toutput[pos++] = charCode>>12 & 0x0F | 0xE0;\r\n\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\r\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\r\n\t\t\t} else {\r\n\t\t\t\toutput[pos++] = charCode>>18 & 0x07 | 0xF0;\r\n\t\t\t\toutput[pos++] = charCode>>12 & 0x3F | 0x80;\r\n\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\r\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\tfunction parseUTF8(input, offset, length) {\r\n\t\tvar output = \"\";\r\n\t\tvar utf16;\r\n\t\tvar pos = offset;\r\n\r\n\t\twhile (pos < offset+length)\r\n\t\t{\r\n\t\t\tvar byte1 = input[pos++];\r\n\t\t\tif (byte1 < 128)\r\n\t\t\t\tutf16 = byte1;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar byte2 = input[pos++]-128;\r\n\t\t\t\tif (byte2 < 0)\r\n\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16),\"\"]));\r\n\t\t\t\tif (byte1 < 0xE0)             // 2 byte character\r\n\t\t\t\t\tutf16 = 64*(byte1-0xC0) + byte2;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvar byte3 = input[pos++]-128;\r\n\t\t\t\t\tif (byte3 < 0)\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\r\n\t\t\t\t\tif (byte1 < 0xF0)        // 3 byte character\r\n\t\t\t\t\t\tutf16 = 4096*(byte1-0xE0) + 64*byte2 + byte3;\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t   var byte4 = input[pos++]-128;\r\n\t\t\t\t\t\t\t\t   if (byte4 < 0)\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\r\n\t\t\t\t\t\t\t\t   if (byte1 < 0xF8)        // 4 byte character\r\n\t\t\t\t\t\t\t\t\t\t   utf16 = 262144*(byte1-0xF0) + 4096*byte2 + 64*byte3 + byte4;\r\n\t\t\t\t\t   else                     // longer encodings are not supported\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\tif (utf16 > 0xFFFF)   // 4 byte character - express as a surrogate pair\r\n\t\t\t\t  {\r\n\t\t\t\t\t utf16 -= 0x10000;\r\n\t\t\t\t\t output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\r\n\t\t\t\t\t utf16 = 0xDC00 + (utf16 & 0x3FF);  // trail character\r\n\t\t\t\t  }\r\n\t\t\toutput += String.fromCharCode(utf16);\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Repeat keepalive requests, monitor responses.\r\n\t * @ignore\r\n\t */\r\n\tvar Pinger = function(client, window, keepAliveInterval) {\r\n\t\tthis._client = client;\r\n\t\tthis._window = window;\r\n\t\tthis._keepAliveInterval = keepAliveInterval*1000;\r\n\t\tthis.isReset = false;\r\n\r\n\t\tvar pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\r\n\r\n\t\tvar doTimeout = function (pinger) {\r\n\t\t\treturn function () {\r\n\t\t\t\treturn doPing.apply(pinger);\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\t/** @ignore */\r\n\t\tvar doPing = function() {\r\n\t\t\tif (!this.isReset) {\r\n\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"Timed out\");\r\n\t\t\t\tthis._client._disconnected( ERROR.PING_TIMEOUT.code , format(ERROR.PING_TIMEOUT));\r\n\t\t\t} else {\r\n\t\t\t\tthis.isReset = false;\r\n\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\r\n\t\t\t\tthis._client.socket.send(pingReq);\r\n\t\t\t\tthis.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.reset = function() {\r\n\t\t\tthis.isReset = true;\r\n\t\t\tthis._window.clearTimeout(this.timeout);\r\n\t\t\tif (this._keepAliveInterval > 0)\r\n\t\t\t\tthis.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\r\n\t\t}\r\n\r\n\t\tthis.cancel = function() {\r\n\t\t\tthis._window.clearTimeout(this.timeout);\r\n\t\t}\r\n\t };\r\n\r\n\t/**\r\n\t * Monitor request completion.\r\n\t * @ignore\r\n\t */\r\n\tvar Timeout = function(client, window, timeoutSeconds, action, args) {\r\n\t\tthis._window = window;\r\n\t\tif (!timeoutSeconds)\r\n\t\t\ttimeoutSeconds = 30;\r\n\r\n\t\tvar doTimeout = function (action, client, args) {\r\n\t\t\treturn function () {\r\n\t\t\t\treturn action.apply(client, args);\r\n\t\t\t};\r\n\t\t};\r\n\t\tthis.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\r\n\r\n\t\tthis.cancel = function() {\r\n\t\t\tthis._window.clearTimeout(this.timeout);\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t * Internal implementation of the Websockets MQTT V3.1 client.\r\n\t *\r\n\t * @name Paho.MQTT.ClientImpl @constructor\r\n\t * @param {String} host the DNS nameof the webSocket host.\r\n\t * @param {Number} port the port number for that host.\r\n\t * @param {String} clientId the MQ client identifier.\r\n\t */\r\n\tvar ClientImpl = function (uri, host, port, path, clientId) {\r\n\t\t// Check dependencies are satisfied in this browser.\r\n\t\tif (!(\"WebSocket\" in global && global[\"WebSocket\"] !== null)) {\r\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\r\n\t\t}\r\n\t\tif (!(\"localStorage\" in global && global[\"localStorage\"] !== null)) {\r\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\r\n\t\t}\r\n\t\tif (!(\"ArrayBuffer\" in global && global[\"ArrayBuffer\"] !== null)) {\r\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\r\n\t\t}\r\n\t\tthis._trace(\"Paho.MQTT.Client\", uri, host, port, path, clientId);\r\n\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t\tthis.path = path;\r\n\t\tthis.uri = uri;\r\n\t\tthis.clientId = clientId;\r\n\r\n\t\t// Local storagekeys are qualified with the following string.\r\n\t\t// The conditional inclusion of path in the key is for backward\r\n\t\t// compatibility to when the path was not configurable and assumed to\r\n\t\t// be /mqtt\r\n\t\tthis._localKey=host+\":\"+port+(path!=\"/mqtt\"?\":\"+path:\"\")+\":\"+clientId+\":\";\r\n\r\n\t\t// Create private instance-only message queue\r\n\t\t// Internal queue of messages to be sent, in sending order.\r\n\t\tthis._msg_queue = [];\r\n\r\n\t\t// Messages we have sent and are expecting a response for, indexed by their respective message ids.\r\n\t\tthis._sentMessages = {};\r\n\r\n\t\t// Messages we have received and acknowleged and are expecting a confirm message for\r\n\t\t// indexed by their respective message ids.\r\n\t\tthis._receivedMessages = {};\r\n\r\n\t\t// Internal list of callbacks to be executed when messages\r\n\t\t// have been successfully sent over web socket, e.g. disconnect\r\n\t\t// when it doesn't have to wait for ACK, just message is dispatched.\r\n\t\tthis._notify_msg_sent = {};\r\n\r\n\t\t// Unique identifier for SEND messages, incrementing\r\n\t\t// counter as messages are sent.\r\n\t\tthis._message_identifier = 1;\r\n\r\n\t\t// Used to determine the transmission sequence of stored sent messages.\r\n\t\tthis._sequence = 0;\r\n\r\n\r\n\t\t// Load the local state, if any, from the saved version, only restore state relevant to this client.\r\n\t\tfor (var key in localStorage)\r\n\t\t\tif (   key.indexOf(\"Sent:\"+this._localKey) == 0\r\n\t\t\t\t|| key.indexOf(\"Received:\"+this._localKey) == 0)\r\n\t\t\tthis.restore(key);\r\n\t};\r\n\r\n\t// Messaging Client public instance members.\r\n\tClientImpl.prototype.host;\r\n\tClientImpl.prototype.port;\r\n\tClientImpl.prototype.path;\r\n\tClientImpl.prototype.uri;\r\n\tClientImpl.prototype.clientId;\r\n\r\n\t// Messaging Client private instance members.\r\n\tClientImpl.prototype.socket;\r\n\t/* true once we have received an acknowledgement to a CONNECT packet. */\r\n\tClientImpl.prototype.connected = false;\r\n\t/* The largest message identifier allowed, may not be larger than 2**16 but\r\n\t * if set smaller reduces the maximum number of outbound messages allowed.\r\n\t */\r\n\tClientImpl.prototype.maxMessageIdentifier = 65536;\r\n\tClientImpl.prototype.connectOptions;\r\n\tClientImpl.prototype.hostIndex;\r\n\tClientImpl.prototype.onConnectionLost;\r\n\tClientImpl.prototype.onMessageDelivered;\r\n\tClientImpl.prototype.onMessageArrived;\r\n\tClientImpl.prototype.traceFunction;\r\n\tClientImpl.prototype._msg_queue = null;\r\n\tClientImpl.prototype._connectTimeout;\r\n\t/* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\r\n\tClientImpl.prototype.sendPinger = null;\r\n\t/* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\r\n\tClientImpl.prototype.receivePinger = null;\r\n\r\n\tClientImpl.prototype.receiveBuffer = null;\r\n\r\n\tClientImpl.prototype._traceBuffer = null;\r\n\tClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\r\n\r\n\tClientImpl.prototype.connect = function (connectOptions) {\r\n\t\tvar connectOptionsMasked = this._traceMask(connectOptions, \"password\");\r\n\t\tthis._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\r\n\r\n\t\tif (this.connected)\r\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\r\n\t\tif (this.socket)\r\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\r\n\r\n\t\tthis.connectOptions = connectOptions;\r\n\r\n\t\tif (connectOptions.uris) {\r\n\t\t\tthis.hostIndex = 0;\r\n\t\t\tthis._doConnect(connectOptions.uris[0]);\r\n\t\t} else {\r\n\t\t\tthis._doConnect(this.uri);\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\r\n\t\tthis._trace(\"Client.subscribe\", filter, subscribeOptions);\r\n\r\n\t\tif (!this.connected)\r\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n\r\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\r\n\t\twireMessage.topics=[filter];\r\n\t\tif (subscribeOptions.qos != undefined)\r\n\t\t\twireMessage.requestedQos = [subscribeOptions.qos];\r\n\t\telse\r\n\t\t\twireMessage.requestedQos = [0];\r\n\r\n\t\tif (subscribeOptions.onSuccess) {\r\n\t\t\twireMessage.onSuccess = function(grantedQos) {subscribeOptions.onSuccess({invocationContext:subscribeOptions.invocationContext,grantedQos:grantedQos});};\r\n\t\t}\r\n\r\n\t\tif (subscribeOptions.onFailure) {\r\n\t\t\twireMessage.onFailure = function(errorCode) {subscribeOptions.onFailure({invocationContext:subscribeOptions.invocationContext,errorCode:errorCode});};\r\n\t\t}\r\n\r\n\t\tif (subscribeOptions.timeout) {\r\n\t\t\twireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure\r\n\t\t\t\t\t, [{invocationContext:subscribeOptions.invocationContext,\r\n\t\t\t\t\t\terrorCode:ERROR.SUBSCRIBE_TIMEOUT.code,\r\n\t\t\t\t\t\terrorMessage:format(ERROR.SUBSCRIBE_TIMEOUT)}]);\r\n\t\t}\r\n\r\n\t\t// All subscriptions return a SUBACK.\r\n\t\tthis._requires_ack(wireMessage);\r\n\t\tthis._schedule_message(wireMessage);\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {\r\n\t\tthis._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\r\n\r\n\t\tif (!this.connected)\r\n\t\t   throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n\r\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\r\n\t\twireMessage.topics = [filter];\r\n\r\n\t\tif (unsubscribeOptions.onSuccess) {\r\n\t\t\twireMessage.callback = function() {unsubscribeOptions.onSuccess({invocationContext:unsubscribeOptions.invocationContext});};\r\n\t\t}\r\n\t\tif (unsubscribeOptions.timeout) {\r\n\t\t\twireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure\r\n\t\t\t\t\t, [{invocationContext:unsubscribeOptions.invocationContext,\r\n\t\t\t\t\t\terrorCode:ERROR.UNSUBSCRIBE_TIMEOUT.code,\r\n\t\t\t\t\t\terrorMessage:format(ERROR.UNSUBSCRIBE_TIMEOUT)}]);\r\n\t\t}\r\n\r\n\t\t// All unsubscribes return a SUBACK.\r\n\t\tthis._requires_ack(wireMessage);\r\n\t\tthis._schedule_message(wireMessage);\r\n\t};\r\n\r\n\tClientImpl.prototype.send = function (message) {\r\n\t\tthis._trace(\"Client.send\", message);\r\n\r\n\t\tif (!this.connected)\r\n\t\t   throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n\r\n\t\twireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\r\n\t\twireMessage.payloadMessage = message;\r\n\r\n\t\tif (message.qos > 0)\r\n\t\t\tthis._requires_ack(wireMessage);\r\n\t\telse if (this.onMessageDelivered)\r\n\t\t\tthis._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\r\n\t\tthis._schedule_message(wireMessage);\r\n\t};\r\n\r\n\tClientImpl.prototype.disconnect = function () {\r\n\t\tthis._trace(\"Client.disconnect\");\r\n\r\n\t\tif (!this.socket)\r\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\r\n\r\n\t\twireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\r\n\r\n\t\t// Run the disconnected call back as soon as the message has been sent,\r\n\t\t// in case of a failure later on in the disconnect processing.\r\n\t\t// as a consequence, the _disconected call back may be run several times.\r\n\t\tthis._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\r\n\r\n\t\tthis._schedule_message(wireMessage);\r\n\t};\r\n\r\n\tClientImpl.prototype.getTraceLog = function () {\r\n\t\tif ( this._traceBuffer !== null ) {\r\n\t\t\tthis._trace(\"Client.getTraceLog\", new Date());\r\n\t\t\tthis._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\r\n\t\t\tfor (var key in this._sentMessages)\r\n\t\t\t\tthis._trace(\"_sentMessages \",key, this._sentMessages[key]);\r\n\t\t\tfor (var key in this._receivedMessages)\r\n\t\t\t\tthis._trace(\"_receivedMessages \",key, this._receivedMessages[key]);\r\n\r\n\t\t\treturn this._traceBuffer;\r\n\t\t}\r\n\t};\r\n\r\n\tClientImpl.prototype.startTrace = function () {\r\n\t\tif ( this._traceBuffer === null ) {\r\n\t\t\tthis._traceBuffer = [];\r\n\t\t}\r\n\t\tthis._trace(\"Client.startTrace\", new Date(), version);\r\n\t};\r\n\r\n\tClientImpl.prototype.stopTrace = function () {\r\n\t\tdelete this._traceBuffer;\r\n\t};\r\n\r\n\tClientImpl.prototype._doConnect = function (wsurl) {\r\n\t\t// When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\r\n\t\tif (this.connectOptions.useSSL) {\r\n\t\t    var uriParts = wsurl.split(\":\");\r\n\t\t    uriParts[0] = \"wss\";\r\n\t\t    wsurl = uriParts.join(\":\");\r\n\t\t}\r\n\t\tthis.connected = false;\r\n\t\tif (this.connectOptions.mqttVersion < 4) {\r\n\t\t\tthis.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\r\n\t\t} else {\r\n\t\t\tthis.socket = new WebSocket(wsurl, [\"mqtt\"]);\r\n\t\t}\r\n\t\tthis.socket.binaryType = 'arraybuffer';\r\n\r\n\t\tthis.socket.onopen = scope(this._on_socket_open, this);\r\n\t\tthis.socket.onmessage = scope(this._on_socket_message, this);\r\n\t\tthis.socket.onerror = scope(this._on_socket_error, this);\r\n\t\tthis.socket.onclose = scope(this._on_socket_close, this);\r\n\r\n\t\tthis.sendPinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\r\n\t\tthis.receivePinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\r\n\r\n\t\tthis._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected,  [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\r\n\t};\r\n\r\n\r\n\t// Schedule a new message to be sent over the WebSockets\r\n\t// connection. CONNECT messages cause WebSocket connection\r\n\t// to be started. All other messages are queued internally\r\n\t// until this has happened. When WS connection starts, process\r\n\t// all outstanding messages.\r\n\tClientImpl.prototype._schedule_message = function (message) {\r\n\t\tthis._msg_queue.push(message);\r\n\t\t// Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\r\n\t\tif (this.connected) {\r\n\t\t\tthis._process_queue();\r\n\t\t}\r\n\t};\r\n\r\n\tClientImpl.prototype.store = function(prefix, wireMessage) {\r\n\t\tvar storedMessage = {type:wireMessage.type, messageIdentifier:wireMessage.messageIdentifier, version:1};\r\n\r\n\t\tswitch(wireMessage.type) {\r\n\t\t  case MESSAGE_TYPE.PUBLISH:\r\n\t\t\t  if(wireMessage.pubRecReceived)\r\n\t\t\t\t  storedMessage.pubRecReceived = true;\r\n\r\n\t\t\t  // Convert the payload to a hex string.\r\n\t\t\t  storedMessage.payloadMessage = {};\r\n\t\t\t  var hex = \"\";\r\n\t\t\t  var messageBytes = wireMessage.payloadMessage.payloadBytes;\r\n\t\t\t  for (var i=0; i<messageBytes.length; i++) {\r\n\t\t\t\tif (messageBytes[i] <= 0xF)\r\n\t\t\t\t  hex = hex+\"0\"+messageBytes[i].toString(16);\r\n\t\t\t\telse\r\n\t\t\t\t  hex = hex+messageBytes[i].toString(16);\r\n\t\t\t  }\r\n\t\t\t  storedMessage.payloadMessage.payloadHex = hex;\r\n\r\n\t\t\t  storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\r\n\t\t\t  storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\r\n\t\t\t  if (wireMessage.payloadMessage.duplicate)\r\n\t\t\t\t  storedMessage.payloadMessage.duplicate = true;\r\n\t\t\t  if (wireMessage.payloadMessage.retained)\r\n\t\t\t\t  storedMessage.payloadMessage.retained = true;\r\n\r\n\t\t\t  // Add a sequence number to sent messages.\r\n\t\t\t  if ( prefix.indexOf(\"Sent:\") == 0 ) {\r\n\t\t\t\t  if ( wireMessage.sequence === undefined )\r\n\t\t\t\t\t  wireMessage.sequence = ++this._sequence;\r\n\t\t\t\t  storedMessage.sequence = wireMessage.sequence;\r\n\t\t\t  }\r\n\t\t\t  break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\r\n\t\t}\r\n\t\tlocalStorage.setItem(prefix+this._localKey+wireMessage.messageIdentifier, JSON.stringify(storedMessage));\r\n\t};\r\n\r\n\tClientImpl.prototype.restore = function(key) {\r\n\t\tvar value = localStorage.getItem(key);\r\n\t\tvar storedMessage = JSON.parse(value);\r\n\r\n\t\tvar wireMessage = new WireMessage(storedMessage.type, storedMessage);\r\n\r\n\t\tswitch(storedMessage.type) {\r\n\t\t  case MESSAGE_TYPE.PUBLISH:\r\n\t\t\t  // Replace the payload message with a Message object.\r\n\t\t\t  var hex = storedMessage.payloadMessage.payloadHex;\r\n\t\t\t  var buffer = new ArrayBuffer((hex.length)/2);\r\n\t\t\t  var byteStream = new Uint8Array(buffer);\r\n\t\t\t  var i = 0;\r\n\t\t\t  while (hex.length >= 2) {\r\n\t\t\t\t  var x = parseInt(hex.substring(0, 2), 16);\r\n\t\t\t\t  hex = hex.substring(2, hex.length);\r\n\t\t\t\t  byteStream[i++] = x;\r\n\t\t\t  }\r\n\t\t\t  var payloadMessage = new Paho.MQTT.Message(byteStream);\r\n\r\n\t\t\t  payloadMessage.qos = storedMessage.payloadMessage.qos;\r\n\t\t\t  payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\r\n\t\t\t  if (storedMessage.payloadMessage.duplicate)\r\n\t\t\t\t  payloadMessage.duplicate = true;\r\n\t\t\t  if (storedMessage.payloadMessage.retained)\r\n\t\t\t\t  payloadMessage.retained = true;\r\n\t\t\t  wireMessage.payloadMessage = payloadMessage;\r\n\r\n\t\t\t  break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t  throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\r\n\t\t}\r\n\r\n\t\tif (key.indexOf(\"Sent:\"+this._localKey) == 0) {\r\n\t\t\twireMessage.payloadMessage.duplicate = true;\r\n\t\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\r\n\t\t} else if (key.indexOf(\"Received:\"+this._localKey) == 0) {\r\n\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\r\n\t\t}\r\n\t};\r\n\r\n\tClientImpl.prototype._process_queue = function () {\r\n\t\tvar message = null;\r\n\t\t// Process messages in order they were added\r\n\t\tvar fifo = this._msg_queue.reverse();\r\n\r\n\t\t// Send all queued messages down socket connection\r\n\t\twhile ((message = fifo.pop())) {\r\n\t\t\tthis._socket_send(message);\r\n\t\t\t// Notify listeners that message was successfully sent\r\n\t\t\tif (this._notify_msg_sent[message]) {\r\n\t\t\t\tthis._notify_msg_sent[message]();\r\n\t\t\t\tdelete this._notify_msg_sent[message];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Expect an ACK response for this message. Add message to the set of in progress\r\n\t * messages and set an unused identifier in this message.\r\n\t * @ignore\r\n\t */\r\n\tClientImpl.prototype._requires_ack = function (wireMessage) {\r\n\t\tvar messageCount = Object.keys(this._sentMessages).length;\r\n\t\tif (messageCount > this.maxMessageIdentifier)\r\n\t\t\tthrow Error (\"Too many messages:\"+messageCount);\r\n\r\n\t\twhile(this._sentMessages[this._message_identifier] !== undefined) {\r\n\t\t\tthis._message_identifier++;\r\n\t\t}\r\n\t\twireMessage.messageIdentifier = this._message_identifier;\r\n\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\r\n\t\tif (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\r\n\t\t\tthis.store(\"Sent:\", wireMessage);\r\n\t\t}\r\n\t\tif (this._message_identifier === this.maxMessageIdentifier) {\r\n\t\t\tthis._message_identifier = 1;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called when the underlying websocket has been opened.\r\n\t * @ignore\r\n\t */\r\n\tClientImpl.prototype._on_socket_open = function () {\r\n\t\t// Create the CONNECT message object.\r\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\r\n\t\twireMessage.clientId = this.clientId;\r\n\t\tthis._socket_send(wireMessage);\r\n\t};\r\n\r\n\t/**\r\n\t * Called when the underlying websocket has received a complete packet.\r\n\t * @ignore\r\n\t */\r\n\tClientImpl.prototype._on_socket_message = function (event) {\r\n\t\tthis._trace(\"Client._on_socket_message\", event.data);\r\n\t\t// Reset the receive ping timer, we now have evidence the server is alive.\r\n\t\tthis.receivePinger.reset();\r\n\t\tvar messages = this._deframeMessages(event.data);\r\n\t\tfor (var i = 0; i < messages.length; i+=1) {\r\n\t\t    this._handleMessage(messages[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tClientImpl.prototype._deframeMessages = function(data) {\r\n\t\tvar byteArray = new Uint8Array(data);\r\n\t    if (this.receiveBuffer) {\r\n\t        var newData = new Uint8Array(this.receiveBuffer.length+byteArray.length);\r\n\t        newData.set(this.receiveBuffer);\r\n\t        newData.set(byteArray,this.receiveBuffer.length);\r\n\t        byteArray = newData;\r\n\t        delete this.receiveBuffer;\r\n\t    }\r\n\t\ttry {\r\n\t\t    var offset = 0;\r\n\t\t    var messages = [];\r\n\t\t    while(offset < byteArray.length) {\r\n\t\t        var result = decodeMessage(byteArray,offset);\r\n\t\t        var wireMessage = result[0];\r\n\t\t        offset = result[1];\r\n\t\t        if (wireMessage !== null) {\r\n\t\t            messages.push(wireMessage);\r\n\t\t        } else {\r\n\t\t            break;\r\n\t\t        }\r\n\t\t    }\r\n\t\t    if (offset < byteArray.length) {\r\n\t\t    \tthis.receiveBuffer = byteArray.subarray(offset);\r\n\t\t    }\r\n\t\t} catch (error) {\r\n\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,error.stack.toString()]));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn messages;\r\n\t}\r\n\r\n\tClientImpl.prototype._handleMessage = function(wireMessage) {\r\n\r\n\t\tthis._trace(\"Client._handleMessage\", wireMessage);\r\n\r\n\t\ttry {\r\n\t\t\tswitch(wireMessage.type) {\r\n\t\t\tcase MESSAGE_TYPE.CONNACK:\r\n\t\t\t\tthis._connectTimeout.cancel();\r\n\r\n\t\t\t\t// If we have started using clean session then clear up the local state.\r\n\t\t\t\tif (this.connectOptions.cleanSession) {\r\n\t\t\t\t\tfor (var key in this._sentMessages) {\r\n\t\t\t\t\t\tvar sentMessage = this._sentMessages[key];\r\n\t\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+sentMessage.messageIdentifier);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._sentMessages = {};\r\n\r\n\t\t\t\t\tfor (var key in this._receivedMessages) {\r\n\t\t\t\t\t\tvar receivedMessage = this._receivedMessages[key];\r\n\t\t\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+receivedMessage.messageIdentifier);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._receivedMessages = {};\r\n\t\t\t\t}\r\n\t\t\t\t// Client connected and ready for business.\r\n\t\t\t\tif (wireMessage.returnCode === 0) {\r\n\t\t\t\t\tthis.connected = true;\r\n\t\t\t\t\t// Jump to the end of the list of uris and stop looking for a good host.\r\n\t\t\t\t\tif (this.connectOptions.uris)\r\n\t\t\t\t\t\tthis.hostIndex = this.connectOptions.uris.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._disconnected(ERROR.CONNACK_RETURNCODE.code , format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Resend messages.\r\n\t\t\t\tvar sequencedMessages = new Array();\r\n\t\t\t\tfor (var msgId in this._sentMessages) {\r\n\t\t\t\t\tif (this._sentMessages.hasOwnProperty(msgId))\r\n\t\t\t\t\t\tsequencedMessages.push(this._sentMessages[msgId]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Sort sentMessages into the original sent order.\r\n\t\t\t\tvar sequencedMessages = sequencedMessages.sort(function(a,b) {return a.sequence - b.sequence;} );\r\n\t\t\t\tfor (var i=0, len=sequencedMessages.length; i<len; i++) {\r\n\t\t\t\t\tvar sentMessage = sequencedMessages[i];\r\n\t\t\t\t\tif (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\r\n\t\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:sentMessage.messageIdentifier});\r\n\t\t\t\t\t\tthis._schedule_message(pubRelMessage);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis._schedule_message(sentMessage);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Execute the connectOptions.onSuccess callback if there is one.\r\n\t\t\t\tif (this.connectOptions.onSuccess) {\r\n\t\t\t\t\tthis.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Process all queued messages now that the connection is established.\r\n\t\t\t\tthis._process_queue();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\r\n\t\t\t\tthis._receivePublish(wireMessage);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBACK:\r\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\r\n\t\t\t\tif (sentMessage) {\r\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\r\n\t\t\t\t\tif (this.onMessageDelivered)\r\n\t\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBREC:\r\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t// If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\r\n\t\t\t\tif (sentMessage) {\r\n\t\t\t\t\tsentMessage.pubRecReceived = true;\r\n\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:wireMessage.messageIdentifier});\r\n\t\t\t\t\tthis.store(\"Sent:\", sentMessage);\r\n\t\t\t\t\tthis._schedule_message(pubRelMessage);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBREL:\r\n\t\t\t\tvar receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\r\n\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+wireMessage.messageIdentifier);\r\n\t\t\t\t// If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\r\n\t\t\t\tif (receivedMessage) {\r\n\t\t\t\t\tthis._receiveMessage(receivedMessage);\r\n\t\t\t\t\tdelete this._receivedMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t}\r\n\t\t\t\t// Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\r\n\t\t\t\tvar pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {messageIdentifier:wireMessage.messageIdentifier});\r\n\t\t\t\tthis._schedule_message(pubCompMessage);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PUBCOMP:\r\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\r\n\t\t\t\tif (this.onMessageDelivered)\r\n\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.SUBACK:\r\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\tif (sentMessage) {\r\n\t\t\t\t\tif(sentMessage.timeOut)\r\n\t\t\t\t\t\tsentMessage.timeOut.cancel();\r\n\t\t\t\t\t// This will need to be fixed when we add multiple topic support\r\n          \t\t\tif (wireMessage.returnCode[0] === 0x80) {\r\n\t\t\t\t\t\tif (sentMessage.onFailure) {\r\n\t\t\t\t\t\t\tsentMessage.onFailure(wireMessage.returnCode);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (sentMessage.onSuccess) {\r\n\t\t\t\t\t\tsentMessage.onSuccess(wireMessage.returnCode);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.UNSUBACK:\r\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\tif (sentMessage) {\r\n\t\t\t\t\tif (sentMessage.timeOut)\r\n\t\t\t\t\t\tsentMessage.timeOut.cancel();\r\n\t\t\t\t\tif (sentMessage.callback) {\r\n\t\t\t\t\t\tsentMessage.callback();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.PINGRESP:\r\n\t\t\t\t/* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\r\n\t\t\t\tthis.sendPinger.reset();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MESSAGE_TYPE.DISCONNECT:\r\n\t\t\t\t// Clients do not expect to receive disconnect packets.\r\n\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\r\n\t\t\t};\r\n\t\t} catch (error) {\r\n\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,error.stack.toString()]));\r\n\t\t\treturn;\r\n\t\t}\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._on_socket_error = function (error) {\r\n\t\tthis._disconnected(ERROR.SOCKET_ERROR.code , format(ERROR.SOCKET_ERROR, [error.data]));\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._on_socket_close = function () {\r\n\t\tthis._disconnected(ERROR.SOCKET_CLOSE.code , format(ERROR.SOCKET_CLOSE));\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._socket_send = function (wireMessage) {\r\n\r\n\t\tif (wireMessage.type == 1) {\r\n\t\t\tvar wireMessageMasked = this._traceMask(wireMessage, \"password\");\r\n\t\t\tthis._trace(\"Client._socket_send\", wireMessageMasked);\r\n\t\t}\r\n\t\telse this._trace(\"Client._socket_send\", wireMessage);\r\n\r\n\t\tthis.socket.send(wireMessage.encode());\r\n\t\t/* We have proved to the server we are alive. */\r\n\t\tthis.sendPinger.reset();\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._receivePublish = function (wireMessage) {\r\n\t\tswitch(wireMessage.payloadMessage.qos) {\r\n\t\t\tcase \"undefined\":\r\n\t\t\tcase 0:\r\n\t\t\t\tthis._receiveMessage(wireMessage);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\tvar pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {messageIdentifier:wireMessage.messageIdentifier});\r\n\t\t\t\tthis._schedule_message(pubAckMessage);\r\n\t\t\t\tthis._receiveMessage(wireMessage);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\r\n\t\t\t\tthis.store(\"Received:\", wireMessage);\r\n\t\t\t\tvar pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {messageIdentifier:wireMessage.messageIdentifier});\r\n\t\t\t\tthis._schedule_message(pubRecMessage);\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(\"Invaild qos=\"+wireMmessage.payloadMessage.qos);\r\n\t\t};\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._receiveMessage = function (wireMessage) {\r\n\t\tif (this.onMessageArrived) {\r\n\t\t\tthis.onMessageArrived(wireMessage.payloadMessage);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Client has disconnected either at its own request or because the server\r\n\t * or network disconnected it. Remove all non-durable state.\r\n\t * @param {errorCode} [number] the error number.\r\n\t * @param {errorText} [string] the error text.\r\n\t * @ignore\r\n\t */\r\n\tClientImpl.prototype._disconnected = function (errorCode, errorText) {\r\n\t\tthis._trace(\"Client._disconnected\", errorCode, errorText);\r\n\r\n\t\tthis.sendPinger.cancel();\r\n\t\tthis.receivePinger.cancel();\r\n\t\tif (this._connectTimeout)\r\n\t\t\tthis._connectTimeout.cancel();\r\n\t\t// Clear message buffers.\r\n\t\tthis._msg_queue = [];\r\n\t\tthis._notify_msg_sent = {};\r\n\r\n\t\tif (this.socket) {\r\n\t\t\t// Cancel all socket callbacks so that they cannot be driven again by this socket.\r\n\t\t\tthis.socket.onopen = null;\r\n\t\t\tthis.socket.onmessage = null;\r\n\t\t\tthis.socket.onerror = null;\r\n\t\t\tthis.socket.onclose = null;\r\n\t\t\tif (this.socket.readyState === 1)\r\n\t\t\t\tthis.socket.close();\r\n\t\t\tdelete this.socket;\r\n\t\t}\r\n\r\n\t\tif (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length-1) {\r\n\t\t\t// Try the next host.\r\n\t\t\tthis.hostIndex++;\r\n\t\t\tthis._doConnect(this.connectOptions.uris[this.hostIndex]);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif (errorCode === undefined) {\r\n\t\t\t\terrorCode = ERROR.OK.code;\r\n\t\t\t\terrorText = format(ERROR.OK);\r\n\t\t\t}\r\n\r\n\t\t\t// Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\r\n\t\t\tif (this.connected) {\r\n\t\t\t\tthis.connected = false;\r\n\t\t\t\t// Execute the connectionLostCallback if there is one, and we were connected.\r\n\t\t\t\tif (this.onConnectionLost)\r\n\t\t\t\t\tthis.onConnectionLost({errorCode:errorCode, errorMessage:errorText});\r\n\t\t\t} else {\r\n\t\t\t\t// Otherwise we never had a connection, so indicate that the connect has failed.\r\n\t\t\t\tif (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\r\n\t\t\t\t\tthis._trace(\"Failed to connect V4, dropping back to V3\")\r\n\t\t\t\t\tthis.connectOptions.mqttVersion = 3;\r\n\t\t\t\t\tif (this.connectOptions.uris) {\r\n\t\t\t\t\t\tthis.hostIndex = 0;\r\n\t\t\t\t\t\tthis._doConnect(this.connectOptions.uris[0]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis._doConnect(this.uri);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(this.connectOptions.onFailure) {\r\n\t\t\t\t\tthis.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext, errorCode:errorCode, errorMessage:errorText});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._trace = function () {\r\n\t\t// Pass trace message back to client's callback function\r\n\t\tif (this.traceFunction) {\r\n\t\t\tfor (var i in arguments)\r\n\t\t\t{\r\n\t\t\t\tif (typeof arguments[i] !== \"undefined\")\r\n\t\t\t\t\targuments[i] = JSON.stringify(arguments[i]);\r\n\t\t\t}\r\n\t\t\tvar record = Array.prototype.slice.call(arguments).join(\"\");\r\n\t\t\tthis.traceFunction ({severity: \"Debug\", message: record\t});\r\n\t\t}\r\n\r\n\t\t//buffer style trace\r\n\t\tif ( this._traceBuffer !== null ) {\r\n\t\t\tfor (var i = 0, max = arguments.length; i < max; i++) {\r\n\t\t\t\tif ( this._traceBuffer.length == this._MAX_TRACE_ENTRIES ) {\r\n\t\t\t\t\tthis._traceBuffer.shift();\r\n\t\t\t\t}\r\n\t\t\t\tif (i === 0) this._traceBuffer.push(arguments[i]);\r\n\t\t\t\telse if (typeof arguments[i] === \"undefined\" ) this._traceBuffer.push(arguments[i]);\r\n\t\t\t\telse this._traceBuffer.push(\"  \"+JSON.stringify(arguments[i]));\r\n\t\t   };\r\n\t\t};\r\n\t};\r\n\r\n\t/** @ignore */\r\n\tClientImpl.prototype._traceMask = function (traceObject, masked) {\r\n\t\tvar traceObjectMasked = {};\r\n\t\tfor (var attr in traceObject) {\r\n\t\t\tif (traceObject.hasOwnProperty(attr)) {\r\n\t\t\t\tif (attr == masked)\r\n\t\t\t\t\ttraceObjectMasked[attr] = \"******\";\r\n\t\t\t\telse\r\n\t\t\t\t\ttraceObjectMasked[attr] = traceObject[attr];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn traceObjectMasked;\r\n\t};\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Public Programming interface.\r\n\t// ------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * The JavaScript application communicates to the server using a {@link Paho.MQTT.Client} object.\r\n\t * <p>\r\n\t * Most applications will create just one Client object and then call its connect() method,\r\n\t * however applications can create more than one Client object if they wish.\r\n\t * In this case the combination of host, port and clientId attributes must be different for each Client object.\r\n\t * <p>\r\n\t * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\r\n\t * (even though the underlying protocol exchange might be synchronous in nature).\r\n\t * This means they signal their completion by calling back to the application,\r\n\t * via Success or Failure callback functions provided by the application on the method in question.\r\n\t * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\r\n\t * of the script that made the invocation.\r\n\t * <p>\r\n\t * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\r\n\t * that are defined on the {@link Paho.MQTT.Client} object.\r\n\t * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\r\n\t *\r\n\t * @name Paho.MQTT.Client\r\n\t *\r\n\t * @constructor\r\n\t *\r\n\t * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\r\n\t * @param {number} port - the port number to connect to - only required if host is not a URI\r\n\t * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\r\n\t * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\r\n\t *\r\n\t * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\r\n\t * @property {number} port - <i>read only</i> the server's port.\r\n\t * @property {string} path - <i>read only</i> the server's path.\r\n\t * @property {string} clientId - <i>read only</i> used when connecting to the server.\r\n\t * @property {function} onConnectionLost - called when a connection has been lost.\r\n\t *                            after a connect() method has succeeded.\r\n\t *                            Establish the call back used when a connection has been lost. The connection may be\r\n\t *                            lost because the client initiates a disconnect or because the server or network\r\n\t *                            cause the client to be disconnected. The disconnect call back may be called without\r\n\t *                            the connectionComplete call back being invoked if, for example the client fails to\r\n\t *                            connect.\r\n\t *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\r\n\t *                            <ol>\r\n\t *                            <li>errorCode\r\n\t *                            <li>errorMessage\r\n\t *                            </ol>\r\n\t * @property {function} onMessageDelivered called when a message has been delivered.\r\n\t *                            All processing that this Client will ever do has been completed. So, for example,\r\n\t *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\r\n\t *                            and the message has been removed from persistent storage before this callback is invoked.\r\n\t *                            Parameters passed to the onMessageDelivered callback are:\r\n\t *                            <ol>\r\n\t *                            <li>{@link Paho.MQTT.Message} that was delivered.\r\n\t *                            </ol>\r\n\t * @property {function} onMessageArrived called when a message has arrived in this Paho.MQTT.client.\r\n\t *                            Parameters passed to the onMessageArrived callback are:\r\n\t *                            <ol>\r\n\t *                            <li>{@link Paho.MQTT.Message} that has arrived.\r\n\t *                            </ol>\r\n\t */\r\n\tvar Client = function (host, port, path, clientId) {\r\n\r\n\t    var uri;\r\n\r\n\t\tif (typeof host !== \"string\")\r\n\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\r\n\r\n\t    if (arguments.length == 2) {\r\n\t        // host: must be full ws:// uri\r\n\t        // port: clientId\r\n\t        clientId = port;\r\n\t        uri = host;\r\n\t        var match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\r\n\t        if (match) {\r\n\t            host = match[4]||match[2];\r\n\t            port = parseInt(match[7]);\r\n\t            path = match[8];\r\n\t        } else {\r\n\t            throw new Error(format(ERROR.INVALID_ARGUMENT,[host,\"host\"]));\r\n\t        }\r\n\t    } else {\r\n\t        if (arguments.length == 3) {\r\n\t\t\t\tclientId = path;\r\n\t\t\t\tpath = \"/mqtt\";\r\n\t\t\t}\r\n\t\t\tif (typeof port !== \"number\" || port < 0)\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\r\n\t\t\tif (typeof path !== \"string\")\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof path, \"path\"]));\r\n\r\n\t\t\tvar ipv6AddSBracket = (host.indexOf(\":\") != -1 && host.slice(0,1) != \"[\" && host.slice(-1) != \"]\");\r\n\t\t\turi = \"ws://\"+(ipv6AddSBracket?\"[\"+host+\"]\":host)+\":\"+port+path;\r\n\t\t}\r\n\r\n\t\tvar clientIdLength = 0;\r\n\t\tfor (var i = 0; i<clientId.length; i++) {\r\n\t\t\tvar charCode = clientId.charCodeAt(i);\r\n\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF)  {\r\n\t\t\t\t i++; // Surrogate pair.\r\n\t\t\t}\r\n\t\t\tclientIdLength++;\r\n\t\t}\r\n\t\tif (typeof clientId !== \"string\" || clientIdLength > 65535)\r\n\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\r\n\r\n\t\tvar client = new ClientImpl(uri, host, port, path, clientId);\r\n\t\tthis._getHost =  function() { return host; };\r\n\t\tthis._setHost = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n\r\n\t\tthis._getPort = function() { return port; };\r\n\t\tthis._setPort = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n\r\n\t\tthis._getPath = function() { return path; };\r\n\t\tthis._setPath = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n\r\n\t\tthis._getURI = function() { return uri; };\r\n\t\tthis._setURI = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n\r\n\t\tthis._getClientId = function() { return client.clientId; };\r\n\t\tthis._setClientId = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n\r\n\t\tthis._getOnConnectionLost = function() { return client.onConnectionLost; };\r\n\t\tthis._setOnConnectionLost = function(newOnConnectionLost) {\r\n\t\t\tif (typeof newOnConnectionLost === \"function\")\r\n\t\t\t\tclient.onConnectionLost = newOnConnectionLost;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\r\n\t\t};\r\n\r\n\t\tthis._getOnMessageDelivered = function() { return client.onMessageDelivered; };\r\n\t\tthis._setOnMessageDelivered = function(newOnMessageDelivered) {\r\n\t\t\tif (typeof newOnMessageDelivered === \"function\")\r\n\t\t\t\tclient.onMessageDelivered = newOnMessageDelivered;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\r\n\t\t};\r\n\r\n\t\tthis._getOnMessageArrived = function() { return client.onMessageArrived; };\r\n\t\tthis._setOnMessageArrived = function(newOnMessageArrived) {\r\n\t\t\tif (typeof newOnMessageArrived === \"function\")\r\n\t\t\t\tclient.onMessageArrived = newOnMessageArrived;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\r\n\t\t};\r\n\r\n\t\tthis._getTrace = function() { return client.traceFunction; };\r\n\t\tthis._setTrace = function(trace) {\r\n\t\t\tif(typeof trace === \"function\"){\r\n\t\t\t\tclient.traceFunction = trace;\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof trace, \"onTrace\"]));\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Connect this Messaging client to its server.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#connect\r\n\t\t * @function\r\n\t\t * @param {Object} connectOptions - attributes used with the connection.\r\n\t\t * @param {number} connectOptions.timeout - If the connect has not succeeded within this\r\n\t\t *                    number of seconds, it is deemed to have failed.\r\n\t\t *                    The default is 30 seconds.\r\n\t\t * @param {string} connectOptions.userName - Authentication username for this connection.\r\n\t\t * @param {string} connectOptions.password - Authentication password for this connection.\r\n\t\t * @param {Paho.MQTT.Message} connectOptions.willMessage - sent by the server when the client\r\n\t\t *                    disconnects abnormally.\r\n\t\t * @param {Number} connectOptions.keepAliveInterval - the server disconnects this client if\r\n\t\t *                    there is no activity for this number of seconds.\r\n\t\t *                    The default value of 60 seconds is assumed if not set.\r\n\t\t * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\r\n\t\t *                    persistent state is deleted on successful connect.\r\n\t\t * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\r\n\t\t * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\r\n\t\t * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\r\n\t\t *                    has been received from the server.\r\n\t\t * A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n\t\t * <ol>\r\n\t\t * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\r\n\t\t * </ol>\r\n\t\t * @config {function} [onFailure] called when the connect request has failed or timed out.\r\n\t\t * A single response object parameter is passed to the onFailure callback containing the following fields:\r\n\t\t * <ol>\r\n\t\t * <li>invocationContext as passed in to the onFailure method in the connectOptions.\r\n\t\t * <li>errorCode a number indicating the nature of the error.\r\n\t\t * <li>errorMessage text describing the error.\r\n\t\t * </ol>\r\n\t\t * @config {Array} [hosts] If present this contains either a set of hostnames or fully qualified\r\n\t\t * WebSocket URIs (ws://example.com:1883/mqtt), that are tried in order in place\r\n\t\t * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\r\n\t\t * one of then succeeds.\r\n\t\t * @config {Array} [ports] If present the set of ports matching the hosts. If hosts contains URIs, this property\r\n\t\t * is not used.\r\n\t\t * @throws {InvalidState} if the client is not in disconnected state. The client must have received connectionLost\r\n\t\t * or disconnected before calling connect for a second or subsequent time.\r\n\t\t */\r\n\t\tthis.connect = function (connectOptions) {\r\n\t\t\tconnectOptions = connectOptions || {} ;\r\n\t\t\tvalidate(connectOptions,  {timeout:\"number\",\r\n\t\t\t\t\t\t\t\t\t   userName:\"string\",\r\n\t\t\t\t\t\t\t\t\t   password:\"string\",\r\n\t\t\t\t\t\t\t\t\t   willMessage:\"object\",\r\n\t\t\t\t\t\t\t\t\t   keepAliveInterval:\"number\",\r\n\t\t\t\t\t\t\t\t\t   cleanSession:\"boolean\",\r\n\t\t\t\t\t\t\t\t\t   useSSL:\"boolean\",\r\n\t\t\t\t\t\t\t\t\t   invocationContext:\"object\",\r\n\t\t\t\t\t\t\t\t\t   onSuccess:\"function\",\r\n\t\t\t\t\t\t\t\t\t   onFailure:\"function\",\r\n\t\t\t\t\t\t\t\t\t   hosts:\"object\",\r\n\t\t\t\t\t\t\t\t\t   ports:\"object\",\r\n\t\t\t\t\t\t\t\t\t   mqttVersion:\"number\"});\r\n\r\n\t\t\t// If no keep alive interval is set, assume 60 seconds.\r\n\t\t\tif (connectOptions.keepAliveInterval === undefined)\r\n\t\t\t\tconnectOptions.keepAliveInterval = 60;\r\n\r\n\t\t\tif (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\r\n\t\t\t}\r\n\r\n\t\t\tif (connectOptions.mqttVersion === undefined) {\r\n\t\t\t\tconnectOptions.mqttVersionExplicit = false;\r\n\t\t\t\tconnectOptions.mqttVersion = 4;\r\n\t\t\t} else {\r\n\t\t\t\tconnectOptions.mqttVersionExplicit = true;\r\n\t\t\t}\r\n\r\n\t\t\t//Check that if password is set, so is username\r\n\t\t\tif (connectOptions.password === undefined && connectOptions.userName !== undefined)\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]))\r\n\r\n\t\t\tif (connectOptions.willMessage) {\r\n\t\t\t\tif (!(connectOptions.willMessage instanceof Message))\r\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"]));\r\n\t\t\t\t// The will message must have a payload that can be represented as a string.\r\n\t\t\t\t// Cause the willMessage to throw an exception if this is not the case.\r\n\t\t\t\tconnectOptions.willMessage.stringPayload;\r\n\r\n\t\t\t\tif (typeof connectOptions.willMessage.destinationName === \"undefined\")\r\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\r\n\t\t\t}\r\n\t\t\tif (typeof connectOptions.cleanSession === \"undefined\")\r\n\t\t\t\tconnectOptions.cleanSession = true;\r\n\t\t\tif (connectOptions.hosts) {\r\n\r\n\t\t\t\tif (!(connectOptions.hosts instanceof Array) )\r\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\r\n\t\t\t\tif (connectOptions.hosts.length <1 )\r\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\r\n\r\n\t\t\t\tvar usingURIs = false;\r\n\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\r\n\t\t\t\t\tif (typeof connectOptions.hosts[i] !== \"string\")\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\r\n\t\t\t\t\tif (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\r\n\t\t\t\t\t\tif (i == 0) {\r\n\t\t\t\t\t\t\tusingURIs = true;\r\n\t\t\t\t\t\t} else if (!usingURIs) {\r\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (usingURIs) {\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!usingURIs) {\r\n\t\t\t\t\tif (!connectOptions.ports)\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n\t\t\t\t\tif (!(connectOptions.ports instanceof Array) )\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n\t\t\t\t\tif (connectOptions.hosts.length != connectOptions.ports.length)\r\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n\r\n\t\t\t\t\tconnectOptions.uris = [];\r\n\r\n\t\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\r\n\t\t\t\t\t\tif (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0)\r\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectOptions.ports[\"+i+\"]\"]));\r\n\t\t\t\t\t\tvar host = connectOptions.hosts[i];\r\n\t\t\t\t\t\tvar port = connectOptions.ports[i];\r\n\r\n\t\t\t\t\t\tvar ipv6 = (host.indexOf(\":\") != -1);\r\n\t\t\t\t\t\turi = \"ws://\"+(ipv6?\"[\"+host+\"]\":host)+\":\"+port+path;\r\n\t\t\t\t\t\tconnectOptions.uris.push(uri);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconnectOptions.uris = connectOptions.hosts;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tclient.connect(connectOptions);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#subscribe\r\n\t\t * @function\r\n\t\t * @param {string} filter describing the destinations to receive messages from.\r\n\t\t * <br>\r\n\t\t * @param {object} subscribeOptions - used to control the subscription\r\n\t\t *\r\n\t\t * @param {number} subscribeOptions.qos - the maiximum qos of any publications sent\r\n\t\t *                                  as a result of making this subscription.\r\n\t\t * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\r\n\t\t *                                  or onFailure callback.\r\n\t\t * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\r\n\t\t *                                  has been received from the server.\r\n\t\t *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n\t\t *                                  <ol>\r\n\t\t *                                  <li>invocationContext if set in the subscribeOptions.\r\n\t\t *                                  </ol>\r\n\t\t * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\r\n\t\t *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\r\n\t\t *                                  <ol>\r\n\t\t *                                  <li>invocationContext - if set in the subscribeOptions.\r\n\t\t *                                  <li>errorCode - a number indicating the nature of the error.\r\n\t\t *                                  <li>errorMessage - text describing the error.\r\n\t\t *                                  </ol>\r\n\t\t * @param {number} subscribeOptions.timeout - which, if present, determines the number of\r\n\t\t *                                  seconds after which the onFailure calback is called.\r\n\t\t *                                  The presence of a timeout does not prevent the onSuccess\r\n\t\t *                                  callback from being called when the subscribe completes.\r\n\t\t * @throws {InvalidState} if the client is not in connected state.\r\n\t\t */\r\n\t\tthis.subscribe = function (filter, subscribeOptions) {\r\n\t\t\tif (typeof filter !== \"string\")\r\n\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\r\n\t\t\tsubscribeOptions = subscribeOptions || {} ;\r\n\t\t\tvalidate(subscribeOptions,  {qos:\"number\",\r\n\t\t\t\t\t\t\t\t\t\t invocationContext:\"object\",\r\n\t\t\t\t\t\t\t\t\t\t onSuccess:\"function\",\r\n\t\t\t\t\t\t\t\t\t\t onFailure:\"function\",\r\n\t\t\t\t\t\t\t\t\t\t timeout:\"number\"\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\tif (subscribeOptions.timeout && !subscribeOptions.onFailure)\r\n\t\t\t\tthrow new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\r\n\t\t\tif (typeof subscribeOptions.qos !== \"undefined\"\r\n\t\t\t\t&& !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2 ))\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\r\n\t\t\tclient.subscribe(filter, subscribeOptions);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#unsubscribe\r\n\t\t * @function\r\n\t\t * @param {string} filter - describing the destinations to receive messages from.\r\n\t\t * @param {object} unsubscribeOptions - used to control the subscription\r\n\t\t * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\r\n\t\t                                      or onFailure callback.\r\n\t\t * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\r\n\t\t *                                    A single response object parameter is passed to the\r\n\t\t *                                    onSuccess callback containing the following fields:\r\n\t\t *                                    <ol>\r\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n\t\t *                                    </ol>\r\n\t\t * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\r\n\t\t *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\r\n\t\t *                                    <ol>\r\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n\t\t *                                    <li>errorCode - a number indicating the nature of the error.\r\n\t\t *                                    <li>errorMessage - text describing the error.\r\n\t\t *                                    </ol>\r\n\t\t * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\r\n\t\t *                                    after which the onFailure callback is called. The presence of\r\n\t\t *                                    a timeout does not prevent the onSuccess callback from being\r\n\t\t *                                    called when the unsubscribe completes\r\n\t\t * @throws {InvalidState} if the client is not in connected state.\r\n\t\t */\r\n\t\tthis.unsubscribe = function (filter, unsubscribeOptions) {\r\n\t\t\tif (typeof filter !== \"string\")\r\n\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\r\n\t\t\tunsubscribeOptions = unsubscribeOptions || {} ;\r\n\t\t\tvalidate(unsubscribeOptions,  {invocationContext:\"object\",\r\n\t\t\t\t\t\t\t\t\t\t   onSuccess:\"function\",\r\n\t\t\t\t\t\t\t\t\t\t   onFailure:\"function\",\r\n\t\t\t\t\t\t\t\t\t\t   timeout:\"number\"\r\n\t\t\t\t\t\t\t\t\t\t  });\r\n\t\t\tif (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)\r\n\t\t\t\tthrow new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\r\n\t\t\tclient.unsubscribe(filter, unsubscribeOptions);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Send a message to the consumers of the destination in the Message.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#send\r\n\t\t * @function\r\n\t\t * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\r\n\t\t * \t\t\t\t\t   - If it is the only parameter, used as Paho.MQTT.Message object.\r\n\t\t * @param {String|ArrayBuffer} payload - The message data to be sent.\r\n\t\t * @param {number} qos The Quality of Service used to deliver the message.\r\n\t\t * \t\t<dl>\r\n\t\t * \t\t\t<dt>0 Best effort (default).\r\n\t\t *     \t\t\t<dt>1 At least once.\r\n\t\t *     \t\t\t<dt>2 Exactly once.\r\n\t\t * \t\t</dl>\r\n\t\t * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n\t\t *                     to both current and future subscriptions.\r\n\t\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n\t\t *                     A received message has the retained boolean set to true if the message was published\r\n\t\t *                     with the retained boolean set to true\r\n\t\t *                     and the subscrption was made after the message has been published.\r\n\t\t * @throws {InvalidState} if the client is not connected.\r\n\t\t */\r\n\t\tthis.send = function (topic,payload,qos,retained) {\r\n\t\t\tvar message ;\r\n\r\n\t\t\tif(arguments.length == 0){\r\n\t\t\t\tthrow new Error(\"Invalid argument.\"+\"length\");\r\n\r\n\t\t\t}else if(arguments.length == 1) {\r\n\r\n\t\t\t\tif (!(topic instanceof Message) && (typeof topic !== \"string\"))\r\n\t\t\t\t\tthrow new Error(\"Invalid argument:\"+ typeof topic);\r\n\r\n\t\t\t\tmessage = topic;\r\n\t\t\t\tif (typeof message.destinationName === \"undefined\")\r\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,\"Message.destinationName\"]));\r\n\t\t\t\tclient.send(message);\r\n\r\n\t\t\t}else {\r\n\t\t\t\t//parameter checking in Message object\r\n\t\t\t\tmessage = new Message(payload);\r\n\t\t\t\tmessage.destinationName = topic;\r\n\t\t\t\tif(arguments.length >= 3)\r\n\t\t\t\t\tmessage.qos = qos;\r\n\t\t\t\tif(arguments.length >= 4)\r\n\t\t\t\t\tmessage.retained = retained;\r\n\t\t\t\tclient.send(message);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Normal disconnect of this Messaging client from its server.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#disconnect\r\n\t\t * @function\r\n\t\t * @throws {InvalidState} if the client is already disconnected.\r\n\t\t */\r\n\t\tthis.disconnect = function () {\r\n\t\t\tclient.disconnect();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Get the contents of the trace log.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#getTraceLog\r\n\t\t * @function\r\n\t\t * @return {Object[]} tracebuffer containing the time ordered trace records.\r\n\t\t */\r\n\t\tthis.getTraceLog = function () {\r\n\t\t\treturn client.getTraceLog();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Start tracing.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#startTrace\r\n\t\t * @function\r\n\t\t */\r\n\t\tthis.startTrace = function () {\r\n\t\t\tclient.startTrace();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop tracing.\r\n\t\t *\r\n\t\t * @name Paho.MQTT.Client#stopTrace\r\n\t\t * @function\r\n\t\t */\r\n\t\tthis.stopTrace = function () {\r\n\t\t\tclient.stopTrace();\r\n\t\t};\r\n\r\n\t\tthis.isConnected = function() {\r\n\t\t\treturn client.connected;\r\n\t\t};\r\n\t};\r\n\r\n\tClient.prototype = {\r\n\t\tget host() { return this._getHost(); },\r\n\t\tset host(newHost) { this._setHost(newHost); },\r\n\r\n\t\tget port() { return this._getPort(); },\r\n\t\tset port(newPort) { this._setPort(newPort); },\r\n\r\n\t\tget path() { return this._getPath(); },\r\n\t\tset path(newPath) { this._setPath(newPath); },\r\n\r\n\t\tget clientId() { return this._getClientId(); },\r\n\t\tset clientId(newClientId) { this._setClientId(newClientId); },\r\n\r\n\t\tget onConnectionLost() { return this._getOnConnectionLost(); },\r\n\t\tset onConnectionLost(newOnConnectionLost) { this._setOnConnectionLost(newOnConnectionLost); },\r\n\r\n\t\tget onMessageDelivered() { return this._getOnMessageDelivered(); },\r\n\t\tset onMessageDelivered(newOnMessageDelivered) { this._setOnMessageDelivered(newOnMessageDelivered); },\r\n\r\n\t\tget onMessageArrived() { return this._getOnMessageArrived(); },\r\n\t\tset onMessageArrived(newOnMessageArrived) { this._setOnMessageArrived(newOnMessageArrived); },\r\n\r\n\t\tget trace() { return this._getTrace(); },\r\n\t\tset trace(newTraceFunction) { this._setTrace(newTraceFunction); }\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * An application message, sent or received.\r\n\t * <p>\r\n\t * All attributes may be null, which implies the default values.\r\n\t *\r\n\t * @name Paho.MQTT.Message\r\n\t * @constructor\r\n\t * @param {String|ArrayBuffer} payload The message data to be sent.\r\n\t * <p>\r\n\t * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\r\n\t * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\r\n\t * <p>\r\n\t * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\r\n\t *                    (for messages about to be sent) or the name of the destination from which the message has been received.\r\n\t *                    (for messages received by the onMessage function).\r\n\t * <p>\r\n\t * @property {number} qos The Quality of Service used to deliver the message.\r\n\t * <dl>\r\n\t *     <dt>0 Best effort (default).\r\n\t *     <dt>1 At least once.\r\n\t *     <dt>2 Exactly once.\r\n\t * </dl>\r\n\t * <p>\r\n\t * @property {Boolean} retained If true, the message is to be retained by the server and delivered\r\n\t *                     to both current and future subscriptions.\r\n\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n\t *                     A received message has the retained boolean set to true if the message was published\r\n\t *                     with the retained boolean set to true\r\n\t *                     and the subscrption was made after the message has been published.\r\n\t * <p>\r\n\t * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\r\n\t *                     This is only set on messages received from the server.\r\n\t *\r\n\t */\r\n\tvar Message = function (newPayload) {\r\n\t\tvar payload;\r\n\t\tif (   typeof newPayload === \"string\"\r\n\t\t\t|| newPayload instanceof ArrayBuffer\r\n\t\t\t|| newPayload instanceof Int8Array\r\n\t\t\t|| newPayload instanceof Uint8Array\r\n\t\t\t|| newPayload instanceof Int16Array\r\n\t\t\t|| newPayload instanceof Uint16Array\r\n\t\t\t|| newPayload instanceof Int32Array\r\n\t\t\t|| newPayload instanceof Uint32Array\r\n\t\t\t|| newPayload instanceof Float32Array\r\n\t\t\t|| newPayload instanceof Float64Array\r\n\t\t   ) {\r\n\t\t\tpayload = newPayload;\r\n\t\t} else {\r\n\t\t\tthrow (format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]));\r\n\t\t}\r\n\r\n\t\tthis._getPayloadString = function () {\r\n\t\t\tif (typeof payload === \"string\")\r\n\t\t\t\treturn payload;\r\n\t\t\telse\r\n\t\t\t\treturn parseUTF8(payload, 0, payload.length);\r\n\t\t};\r\n\r\n\t\tthis._getPayloadBytes = function() {\r\n\t\t\tif (typeof payload === \"string\") {\r\n\t\t\t\tvar buffer = new ArrayBuffer(UTF8Length(payload));\r\n\t\t\t\tvar byteStream = new Uint8Array(buffer);\r\n\t\t\t\tstringToUTF8(payload, byteStream, 0);\r\n\r\n\t\t\t\treturn byteStream;\r\n\t\t\t} else {\r\n\t\t\t\treturn payload;\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tvar destinationName = undefined;\r\n\t\tthis._getDestinationName = function() { return destinationName; };\r\n\t\tthis._setDestinationName = function(newDestinationName) {\r\n\t\t\tif (typeof newDestinationName === \"string\")\r\n\t\t\t\tdestinationName = newDestinationName;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\r\n\t\t};\r\n\r\n\t\tvar qos = 0;\r\n\t\tthis._getQos = function() { return qos; };\r\n\t\tthis._setQos = function(newQos) {\r\n\t\t\tif (newQos === 0 || newQos === 1 || newQos === 2 )\r\n\t\t\t\tqos = newQos;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(\"Invalid argument:\"+newQos);\r\n\t\t};\r\n\r\n\t\tvar retained = false;\r\n\t\tthis._getRetained = function() { return retained; };\r\n\t\tthis._setRetained = function(newRetained) {\r\n\t\t\tif (typeof newRetained === \"boolean\")\r\n\t\t\t\tretained = newRetained;\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\r\n\t\t};\r\n\r\n\t\tvar duplicate = false;\r\n\t\tthis._getDuplicate = function() { return duplicate; };\r\n\t\tthis._setDuplicate = function(newDuplicate) { duplicate = newDuplicate; };\r\n\t};\r\n\r\n\tMessage.prototype = {\r\n\t\tget payloadString() { return this._getPayloadString(); },\r\n\t\tget payloadBytes() { return this._getPayloadBytes(); },\r\n\r\n\t\tget destinationName() { return this._getDestinationName(); },\r\n\t\tset destinationName(newDestinationName) { this._setDestinationName(newDestinationName); },\r\n\r\n\t\tget qos() { return this._getQos(); },\r\n\t\tset qos(newQos) { this._setQos(newQos); },\r\n\r\n\t\tget retained() { return this._getRetained(); },\r\n\t\tset retained(newRetained) { this._setRetained(newRetained); },\r\n\r\n\t\tget duplicate() { return this._getDuplicate(); },\r\n\t\tset duplicate(newDuplicate) { this._setDuplicate(newDuplicate); }\r\n\t};\r\n\r\n\t// Module contents.\r\n\treturn {\r\n\t\tClient: Client,\r\n\t\tMessage: Message\r\n\t};\r\n})(window);\r\n"]},"metadata":{},"sourceType":"module"}